\section{STLC Examples}

%% Here are examples I would like to add
%
%    i) \x.x                (Identity)
%   ii) \x.\y.xy            (Application function)
%  iii) ((\x.\y.(x+y))3)5   (Obviously with N and + added)
%   iv) (\x.x)(\x.x)        (Doesn't type-check)
%    v) \x.xx               (Doesn't type-check (M combinator (Mockingbird)))
%   vi) \x.\y.((xy)(xy))    (Doesn't type-check)
%  vii) \x.\y.\z.x(yz)      (B combinator (Bluebird))
% viii) \x.\y.\z.xyzz       (W* combinator (Warbler once removed))
%   ix) \x.\y.y(xy)         (O combinator (Owl))
%    x) \x.\y.\z.x(y,z)     (Curry)


%Untyped lambda calculus, as we mentioned, is in fact \emph{stronger} than the typed lambda calculus. This we will see by looking at some examples of type checking. Many of these are combinators from untyped lambda calculus in combinatory logic. \ref{} [[Need reference of Mockingbird combinator thing]]

%Note we don't have very much choice on types, so it may be useful to enrich our type theory with $+$-types or even the natural numbers. But we will see soon that these both are special cases of dependent types.

\subsection{Identity function $\lambda x . x$}

\begin{example}[Identity function]
    Let's consider the following lambda term $\lambda x . x$. We wish to find a type $T$ such that given some context $\Gamma$ we have $\Gamma \vdash \lambda x . x \Leftarrow T$. The only rule that allows us to get to this judgement is the mode-switching rule (switch). We also have the oppurtunity to add some structure to the type, so we keep this in mind.
    \begin{prooftree}
        \AxiomC{$\Gamma \vdash \lambda x . x \Rightarrow \boxed{?}$}
        \AxiomC{$\Gamma \vdash T \equiv \boxed{?} \ \mathsf{type}$}
        \RightLabel{(switch)}
        \BinaryInfC{$\Gamma \vdash \lambda x . x \Leftarrow T$}
    \end{prooftree}
    
    A first guess on what $\boxed{?}$ is could be $T$. But this would be a baseless claim to make. Since our syntax has some structure, we can infer what the type ought to be. Checking the conclusions of our rules, we need to find something that will roughly match $\Gamma \vdash \lambda x . x \Rightarrow \boxed{?}$}. We see that there is only one rule that fits: ($\to$-intro). We also see that $\boxed{?}$ will have to be $A \to B$ for some types $A$ and $B$. So we \emph{must} have the following hypothesis in order to progress:
    \begin{equation*}
        \Gamma \vdash T \equiv A \to B\ \mathsf{type} \tag{$*$}
    \end{equation*}
     Hence we must have the following derivation:
     
     \begin{prooftree}
        \AxiomC{$\Gamma , x : A \vdash x \Leftarrow B$}
        \LeftLabel{($\to$-intro)}
        \UnaryInfC{$\Gamma \vdash \lambda x . x \Rightarrow A \to B$}
        \AxiomC{$\Gamma \vdash T \equiv A \to B \ \mathsf{type}$}
        \RightLabel{(switch)}
        \BinaryInfC{$\Gamma \vdash \lambda x . x \Leftarrow T$}
     \end{prooftree}
     
     We need to now resolve the hypothesis $\Gamma , x : A \vdash x \Leftarrow B$. Observing the conclusions of our rules we see that we must mode-switch. As before we have a chance to change our type, so we play the same game with the holes:
     
     \begin{prooftree}
        \AxiomC{$\Gamma , x : A\vdash x \Rightarrow \boxed{?}$}
        \AxiomC{$\Gamma , x : A \vdash B \equiv \boxed{?} \ \mathsf{type}$}
        \RightLabel{(switch)}
        \BinaryInfC{$\Gamma , x : A \vdash x \Leftarrow B$}
        \LeftLabel{($\to$-intro)}
        \UnaryInfC{$\Gamma \vdash \lambda x . x \Rightarrow A \to B$}
        \AxiomC{$\Gamma \vdash T \equiv A \to B \ \mathsf{type}$}
        \RightLabel{(switch)}
        \insertBetweenHyps{\hskip -90pt}
        \BinaryInfC{$\Gamma \vdash \lambda x . x \Leftarrow T$}
     \end{prooftree}
     
     Now observe that there is precisely one rule, the variable rule (var), with a hypothesis in the form of $\Gamma , x : A\vdash x \Rightarrow \boxed{?}$, but for this to be correct we have to place $A$ into $\boxed{?}$. This means we will have to assume:
     \begin{equation*}
        \Gamma , x : A \vdash B \equiv A \ \mathsf{type} \tag{$**$}
     \end{equation*}
     But since the hypothesis of (var) is quite clearly true, namely that $(x : A) \in \Gamma, x : A$ we are done! Here is the full derivation tree:
     
      \begin{prooftree}
        \AxiomC{$(x : A) \in \Gamma, x : A$}
        \LeftLabel{(var)}
        \UnaryInfC{$\Gamma , x : A\vdash x \Rightarrow A$}
        \AxiomC{$\Gamma , x : A \vdash B \equiv A \ \mathsf{type}$}
        \RightLabel{(switch)}
        \BinaryInfC{$\Gamma , x : A \vdash x \Leftarrow B$}
        \LeftLabel{($\to$-intro)}
        \UnaryInfC{$\Gamma \vdash \lambda x . x \Rightarrow A \to B$}
        \AxiomC{$\Gamma \vdash T \equiv A \to B \ \mathsf{type}$}
        \RightLabel{(switch)}
        \insertBetweenHyps{\hskip -90pt}
        \BinaryInfC{$\Gamma \vdash \lambda x . x \Leftarrow T$}
     \end{prooftree}
     
     However we are not quite done yet. We have two type equations $(*)$ and $(**)$ to resolve. It is clear that if we choose $B := A$ and $T := A \to A$ we can resolve all our equational hypotheses. So in actual fact a derivation tree would look like this:
     \begin{prooftree}
        \AxiomC{$(x : A) \in \Gamma, x : A$}
        
        \RightLabel{(var)}
        \UnaryInfC{$\Gamma , x : A\vdash x \Rightarrow A$}
        
        \RightLabel{(cswitch)}
        \UnaryInfC{$\Gamma , x : A \vdash x \Leftarrow A$}
        
        \RightLabel{($\to$-intro)}
        \UnaryInfC{$\Gamma \vdash \lambda x . x \Rightarrow A \to A$}
        
        \RightLabel{(cswitch)}
        \UnaryInfC{$\Gamma \vdash \lambda x . x \Leftarrow A \to A$}
     \end{prooftree}
     
     It is clear when using the compact mode-switching, the derivation tree is much easier to understand and read. But when searching for a type we necessarily have to use regular mode-switching.
     
     \begin{comment} This leaves us with one hypothesis to resolve, $\Gamma , x : A \vdash x \Leftarrow B$ which is clearly true by the variable rule (Var) and nothing else. Thus as long as we can find two types $A$ and $B$
    
     Our inversion lemma will tell us exactly which rules let us get to this point. So we will essentially be performing a tree search.

    
     Firstly we need to switch modes to get $\lambda x . x \Rightarrow T$. But mode switching also lets us change our type just as long as we have an equality. We will not be able to resolve this equality, but we can keep a hold of it as a hypothetical.
    \begin{prooftree}
        \AxiomC{$\Gamma \vdash $}
        \AxiomC{$$}
        \BinaryInfC{$\Gamma \vdash \lambda x . x \Rightarrow T$}
    \end{prooftree}
\end{example}

     \end{comment}

\subsection{Function application $\lambda x . \lambda y . x y$}

\begin{example}[Function application]
    Here is another example of a term that type checks. We want to find a type $T$ such that $\Gamma \vdash \lambda x . \lambda y . x y \Leftarrow T$ is true. A derivation tree can be found in Appendix \ref{ex2}. Here is a proof:
        
    \begin{proof}
        We begin with the judgement $\Gamma \vdash \lambda x . \lambda y . x y \Leftarrow T$, now the only way to arrive at this judgement is via the mode-switching rule.
        Whilst doing this we add type variables $A$ and $B$ which can easily be seen to form into $A \to B$ and let $T \equiv A \to B$.
        We can come back later and validate this judgement.
        The mode-switching should have given us $\Gamma \vdash \lambda x . \lambda y . x y \Rightarrow A \to B$ which we can only arrive at by applying the ($\to$-intro) rule. This gives us $\Gamma , x : A \vdash \lambda y . xy \Leftarrow B$.
        Which we have to mode-switch, and as before we take this chance to introduce type variables $C$ and $D$ in order to arrive at the judgement $\Gamma , x : A \vdash \lambda y . x y \Rightarrow C \to D$.
        This allows us to apply ($\to$-intro) giving us $\Gamma , x : A , y : C \vdash xy \Leftarrow D$.
        Now we apply the ($\to$-elim) rule since we have an application.
        For this we need $\Gamma , x : A, y : C \vdash y \Leftarrow C$, which is marked as $(\dagger)$, and observe that a simple application of mode-switching and the variable rule allows us to derive this judgement.
        The other hypothesis we need is $\Gamma , x : A, y : C \vdash x \Leftarrow C \to D$.
        Again by mode-switching and setting $C \to D \equiv A$ we get $\Gamma , x : A, y : C \vdash x \Rightarrow A$ which is clearly derivable by the variable rule.
            
        Now we have 3 type equations $(*)$, $(**)$ and $(***)$, substituting back in we get $\Gamma \vdash T \equiv (C \to D) \to C \to D$ for some types $C$ and $D$. So $\Gamma \vdash \lambda x . \labmda y . x y \Leftarrow T$ if we have types $C$ and $D$.
    \end{proof}
\end{example}

\begin{remark}
    The density of information in the previous proof is one reason why it is sometimes clearer to draw a derivation tree. The crucial lesson is the choices we have to make at each step. We have set up our rules in such a manner that there is very often only \emph{one} choice that can be made. When being ambiguous about the type we start with, we are in essense \emph{inferring} typing information. Simply typed lambda calculus where the terms do not have typing information is typically referred to as Curry-style. Where as when terms are annotated with their types it is referred to as Church-style \cite{Sorensen}.
\end{remark}

\begin{comment}
\begin{remark}
    There is a lot going on the the previous example, but crucially it should be observed that it is in fact the \emph{inversion lemmas} that allow us to make choices of which rules to use. So a type-checking algorithm would have to make choices based on what the inversion lemmas say. We also introduced equalities of types which was brushed over. In general, type equalities are only generated by reflexivity so in a way our equations were lifted to equality of syntax. This gave us a classical equality problem. Since all our syntax are trees, we can easily decide their equality. [[CAN YOU???!!]]
\end{remark}
\end{comment}

%% Here are examples I would like to add
%
%    i) \x.x                (Identity)
%   ii) \x.\y.xy            (Application function)
%   iv) (\x.x)(\x.x)        (Doesn't type-check)
%    v) \x.xx               (Doesn't type-check (M combinator (Mockingbird)))
%   vi) \x.\y.((xy)(xy))    (Doesn't type-check)
%  vii) \x.\y.\z.x(yz)      (B combinator (Bluebird) function composition!)
%   ix) \x.\y.y(xy)         (O combinator (Owl))
%    x) \x.\y.\z.x(y,z)     (Curry!)

\subsection{Mockingbird $\lambda x . x x$} % Definitely does not type check M

In the untyped lambda calculus, $\lambda$-terms with no free variables can be called combinators. By combining combinators interesting expressions can be written in a readable way. This is related to the idea of combinatory logic which was mostly developed by Haskell Curry. Many combinators have been recorded and one of the best known references is \cite{smullyan2012mock}, \emph{``To Mock a Mockingbird''}. We will take a look at some other combinators later but we will start with the Mockingbird, also known as $\lambda x . x x$.

\begin{example}\label{mockingbird}
    We wish to find a type $T$ such that $\Gamma \vdash \lambda x . x x \Leftarrow T$ for some context $\Gamma$. We begin, as with every begining, with the (switch) rule. We take this time to assume that $\Gamma \vdash T \equiv A \to B \ \mathsf{type}$ given that there is no other way for a $\lambda$-term, as discussed in previous examples. This gives us $\Gamma \vdash \lambda x . x x \Rightarrow A \to B$. Observing that we can only apply ($\to$-intro) we arrive at $\Gamma , x : A\vdash x x \Leftarrow B$. First performing a (cswitch) we get $\Gamma , x : A\vdash x x \Rightarrow B$ which then points us to ($\to$-elim). This gives us $\Gamma , x : A \vdash x \Leftarrow \boxed{?}$ and $\Gamma , x : A \vdash x \Leftarrow \boxed{?} \to B$. Now we need to resolve both of these, the first is easier. We can see that we will have to (cswitch) and then use the variable rule, since this is the only judgement that matches with our hole. This also allows us to deduce that $\boxed{?}$ can be filled with $A$, yielding $\Gamma , x : A \vdash x \Leftarrow A \to B$. This is where things become problematic. We can of course apply the switch rule. But the only way to do this is with the hypothesis $\Gamma , x : A \vdash A \equiv A \to B \ \mathsf{type}$. And we see that $\Gamma , x : A \vdash x \Rightarrow A$ resolves via (var).
    At this point it would seem we are done, but now we will show the importance of checking the type equations we hypothesised. We set up judgemental equality in such a way that if $\Gamma \vdash A \equiv B \ \mathsf{type}$ then the abts $A$ and $B$ where equal as abts. Thus we have an equation $A = A \to B$, but this is impossible!
    This means that the term $\lambda x . x x$ cannot be typed! This is the first stark difference we have seen compared to the untyped lambda calculus. It is typical to assume that by adding typing information to lambda calculus we will break nothing. But as we can clearly see, this is not the case. 
\end{example}

\begin{remark}
    This also presents an oppurtunity to show why we can \emph{only normalise typed terms}. Using the notion of $\beta$-reduction we define back in \ref{beta_reduction}, it appears that $\lambda x . x x$ is in \emph{($\beta$-)normal form}. This is misleading since any application of this function to some other term will not be able to reach normal form:
    \begin{equation*}
        (\lambda x. x x)(\lambda x . x x) \to_{\beta} y y [\lambda x . x x / y] = (\lambda x . x x)(\lambda x . x x) \to_{\beta} \cdots
    \end{equation*}
    This is very similar to the example in Remark \ref{beta_non_normalising_remark}. Of course here, we have stayed fixed, but it is not too difficult to see how a term such as $\lambda x . x x x$ can get very much out of hand when attempting to normalise it.
    So it is not as if typing is a proof trick, which allows us to prove normalisation, but a property of computation in STLC. Only well-typed programs can run.
\end{remark}

\subsection{Aye-aye $(\lambda x . x)(\lambda x . x)$} %  MI

It doesn't mean however any expression containing an ill-typed term is ill-typed. Take for instance $(\lambda x . x)( \lambda x . x)$ which may be written as ($\lambda x . x x) (\lambda x . x)$. As we saw in \ref{mockingbird}, $\lambda x . x x$ cannot be typed.

\begin{example}\label{ayeaye}
    Now suppose we want to show $\Gamma \vdash (\lambda x . x)(\lambda x . x) \Leftarrow T$ for some type $T$. We begin with (cswitch) noting that we will later use ($\to$-elim) so there is no reason to introduce an equality. From $\Gamma \vdash (\lambda x . x)(\lambda x . x) \Rightarrow T$ we use ($\to$-elim) to arive with two hypotheses $\Gamma \vdash \lambda x . x \Leftarrow A \to T$ and $\Gamma \vdash \lambda x. x \Leftarrow A$ for some type $A$. Here we might be inclined to think something has gone wrong, since we have the same term being typed in two different ways! But this is not the case.
    
    We noted in [[ALPHA EQUIVALENCE]] that variables were really just considered up to $\alpha$-equivalence and that it is always sensible to change when things get confusing. We also noted that such intricacies are the source of many problems in theory and implementation of type theories.
    It's not hard to see that $\lambda x . x$ can have any type $A \to A$ we give it. This is because it is simply the identity function. Therefore we could have equally written the judgements as $\Gamma \vdash \lambda x . x \Leftarrow A \to T$ and $\Gamma \vdash \lambda y . y \Leftarrow A$ and this would not have been confusing.
    
    Working on the first we see that after a (cswitch) we get $\Gamma \vdash \lambda x . x \Rightarrow A \to T$ which allows us to use ($\to$-intro) giving us $\Gamma , x : A\vdash x \Leftarrow T$. We see that switching with $\Gamma , x : A \vdash T \equiv A \ \mathsf{type}$ leads to $\Gamma , x : A \vdash x \Rightarrow A$ which is obviously true by (var).
    Applying the weakening rule on our type equation $\Gamma , x : A \vdash T \equiv A \ \mathsf{type}$ gives us $\Gamma \vdash T \equiv A \ \mathsf{type}$ hence going back to $\Gamma \vdash \lambda y . y \Leftarrow A$ we can switch with $\Gamma \vdash A \equiv C \to D$ in order to be able to progress with ($\to$-intro).
    Now applying ($\to$-intro) to $\Gamma \vdash \lambda y . y \Rightarrow C \to D$ we get $\Gamma , y : C \vdash y \Leftarrow D$. Mode switching with $\Gamma , y : C, \vdash D \equiv C \ \mathsf{type}$ we get $\Gamma , y : C \vdash y \Rightarrow C$ which is true by (var).
    We finally see that $\Gamma \vdash T \equiv C \to C\ \mathsf{type}$, and that $\Gamma \vdash (\lambda x . x)(\lambda x . x) \Rightarrow A \to A$ for some type $A$. An important thing to note, is that even though we have two syntactically identical terms that look like $\lambda x . x$ the type information we gave them had to be different. In this case $(A \to A) \to (A \to A)$ for the first occurance and $A \to A$ for the second. 

    \begin{prooftree}
        \def\ScoreOverhang{1pt}
        \AxiomC{$(x : A \to A) \in \Gamma , x : A \to A$}
        \LeftLabel{(var)}
        \UnaryInfC{$\Gamma , x : A \to A \vdash x \Rightarrow A \to A$}
        \LeftLabel{(cswitch)}
        \UnaryInfC{$\Gamma , x : A \to A \vdash x \Leftarrow A \to A$}
        \LeftLabel{($\to$-intro)}
        \UnaryInfC{$\Gamma \vdash \lambda x . x \Rightarrow (A \to A) \to (A \to A)$}
        \LeftLabel{(cswitch)}
        \UnaryInfC{$\Gamma \vdash \lambda x . x \Leftarrow (A \to A) \to (A \to A)$}
        
        \AxiomC{$(x : A) \in \Gamma , x : A$}
        \RightLabel{(var)}
        \UnaryInfC{$\Gamma , x : A \vdash x \Rightarrow A$}
        \RightLabel{(cswitch)}
        \UnaryInfC{$\Gamma , x : A \vdash x \Leftarrow A$}
        \RightLabel{($\to$-intro)}
        \UnaryInfC{$\Gamma \vdash \lambda x . x \Rightarrow A \to A$}
        \RightLabel{(cswitch)}
        \UnaryInfC{$\Gamma \vdash \lambda x . x \Leftarrow A \to A$}
        
        \insertBetweenHyps{\hskip 10pt}
        \LeftLabel{($\to$-elim)}
        \BinaryInfC{$\Gamma \vdash (\lambda x . x)(\lambda x . x) \Rightarrow A \to A$}
        \LeftLabel{(cswitch)}
        \UnaryInfC{$\Gamma \vdash (\lambda x . x)(\lambda x . x) \Leftarrow A \to A$}
    \end{prooftree}

\end{example}

%\subsection{Bluebird mocks the bluebird $\lambda x . \lambda y . (xy)(xy)$} % Does not type check BMB




\subsection{$\mathbf{Y}$-combinator $\lambda x . (\lambda y . x (y y)) (\lambda y . x (y y))$} % Does not type check :O oh no!! no recursion!

Here is an important example from the untyped lambda calculus, the $\mathbf{Y}$-combinator is defined as $\mathbf{Y} = \lambda x . (\lambda y . x (y y)) (\lambda y . x (y y))$.
$\beta$-reducing the $\mathbf{Y}$-combinator applied to a function $f$, we see that $\mathbf{Y}f = f (\mathbf{Y} f)$. This is precisely the behaviour that allows it to attain recursive behaviour.
The $\mathbf{Y}$-combinator allows one to define recursive functions. Due to the non-normalising nature of the untyped lambda calculus, it isn't garanteed that a given function will have a terminating $\beta$-reduction sequence.
One vital thing the $\mathbf{Y}$-combinator provides is an \emph{induction princple} for Church-numerals. It allows one to define functions on Church-numerals by specifying how it acts on zero and on the successor.
We will see that the $\mathbf{Y}$-combinator \emph{cannot} be typed. This doesn't bode well for the use of Church-numerals in simply typed lambda calculus.

[[TODO add references showing off $\mathbf{Y}$-combinator]]

\begin{example}
    We wish to derive $\Gamma \vdash \lambda x . (\lambda y . x( y y)) (\lambda y . x (y y)) \Leftarrow T$ for some type $T$. We begin by switching and letting $T \equiv A \to B$ for some $A$ and $B$. Then we can apply ($\to$-intro) to arrive at $\Gamma , x : A \vdash (\lambda y . x (y y))(\lambda y . x (yy) ) \Leftarrow B$. Switching then applying ($\to$-elim) we need two derivations $\Gamma , x : A \vdash \lambda y . x (y y) \Leftarrow C \to B$ and $\Gamma , x : A \vdash \lambda y . x (y y) \Leftarrow C$, for some $C$. Applying switch on the former and then ($\to$-intro) we arive at $\Gamma , x : A, y : C \vdash x ( y y) \Leftarrow B$. Yet again, we apply switch and ($\to$-elim) to arrive at two derivations: $\Gamma, x : A, y : C \vdash x \Leftarrow D \to B$ and $\Gamma , x : A, y : C \vdash y y \Leftarrow D$ for some type $D$. Switching and applying ($\to$-elim) on the latter we get another two derivations $\Gamma , x : A, y : C \vdash y \Leftarrow E \to D$ and $\Gamma , x : A, y : C \vdash y \Leftarrow E$. Observe that only switching and applying (var) can finish this branch of the tree, leading to the hypotheses $\Gamma , x : A, y : C \vdash C \equiv E \to D \ \mathsf{type}$ and $\Gamma , x : A, y : C \vdash C \equiv E$. Clearly these two give us $C \equiv C \to D$ which is impossible. Hence the $\mathbf{Y}$-combinator cannot be typed. 
\end{example}


\subsection{Function composition $\lambda x . \lambda y . \lambda z . x ( y z)$} % Function comp

Here we will try something different, and perhaps more typical. We will provide ourselves with the type. We wish to check that function composition, written as $\lambda x.\lambda y.\lambda z.x(yz)$ has the type we expect it to: $(B \to C) \to (A \to B) \to (A \to C)$.

\begin{example}
    We will show that for some types $A$, $B$ and $C$, we have function composition $\Gamma \vdash \lambda x.\lambda y.\lambda z.x(yz) \Leftarrow (B \to C) \to (A \to B) \to (A \to C)$.
    A nice thing about being given the type is that type checking becomes much simpler. In fact, there is very little we actually need to do. Oberserve that in Appendix \ref{ex7} we have a derivation tree. We could write this all out as a proof but it would be pointless. As can be seen the derivation tree is much easier to read.
    This is the convention we will take for terms with a given type from now on: giving only a derivation tree.
    
\end{example}



\subsection{Currying $\lambda x . \lambda y . \lambda z . x (y, z)$} % Curry
Here is an interesting function that is quite useful.
[[TODO discuss currying]]
A full derivation is given in \ref{ex8}.

\subsection{Uncurrying $\lambda x . \lambda y . x (\fst(y))(\snd(y))$} % uncurry
[[TODO discuss un-doing functions]]

A full derivation is given in \ref{ex9}.

\subsection{Curry-Uncurry}

We will now show that composing curry with uncurry gives us the identity. Unfortunately $\lambda$-terms will get very large so we will instead write them in a shorter way.
\begin{example}[Curry-Uncurry]\label{curry_uncurry}
    We will assume the following:
    \begin{itemize}
    \item $\Gamma \vdash \mathbf{C} \equiv \lambda x . \lambda y . \lambda z . x (y, z) : (A \times B \to C) \to A \to B \to C$ denotes the function Curry.    
    \item $\Gamma \vdash \mathbf{U} \equiv \lambda x . \lambda y . x (\fst(y))(\snd(y)) : (A \to B \to C) \to A \times B \to C$ denotes the function Uncurry.
    \item $\Gamma \vdash \mathbf{B} \equiv \lambda x . \lambda y . \lambda z . x ( y z) : ((A \to B \to C) \to A \times B \to C) \to ((A \times B \to C) \to A \to B \to C) \to (A \times B \to C) \to (A \times B \to C)$ is the composition of two functions, conveniently with the correct types for curry and uncurry.
    \end{itemize}

    This means we want to derive the following:
    $$
        \Gamma \vdash \mathbf{B} \mathbf{U} \mathbf{C} \equiv \lambda x . x : (A \times B \to C) \to (A \times B \to C)
    $$
    
    Luckily we won't do this by hand and we will instead use a property of our type theory: Canonicity. This says that the normal form of a type is canonical. This means that reducing our terms to $\beta \eta$-normal form will be equal by reflexivity. Clearly $\lambda x . x$ is in normal form so we need to work on the left hand side.
    
    First let us reduce $\mathbf{B} \mathbf{U}$:
    
    \begin{equation*}
        \begin{aligned}
            \mathbf{B} \mathbf{U} &= (\lambda x . \lambda y . \lambda z . x (y z)) (\lambda x .\lambda y. x (\fst(y))(\snd(y)) \\
            &= (\lambda a . \lambda b . \lambda c . a (b c)) (\lambda x .\lambda y. x (\fst(y))(\snd(y)) \\
            &\to_{\beta} \lambda b . \lambda c . (\lambda x .\lambda y. x (\fst(y))(\snd(y)) (b c)  \\
            &\to_{\beta} \lambda b . \lambda c . \lambda y. b c(\fst(y))(\snd(y))  \\
        \end{aligned}
    \end{equation*}
    
    We are now in normal form for $\mathbf{B} \mathbf{U}$ so we can reduce the whole of $\mathbf{B} \mathbf{U} \mathbf{C}$:
    \begin{equation*}
        \begin{aligned}
            \mathbf{B} \mathbf{U} \mathbf{C} &= \mathbf{B} \mathbf{U} (\lambda i . \lambda j . \lambda k . i (j , k)) \\
            &\twoheadrightarrow_{\beta} (\lambda b . \lambda c . \lambda y. b c(\fst(y))(\snd(y))) (\lambda i . \lambda j . \lambda k . i (j , k)) \\
            &\to_{\beta} \lambda c . \lambda y.  (\lambda i . \lambda j . \lambda k . i (j , k)) c(\fst(y))(\snd(y)) \\
            &\to_{\beta} \lambda c . \lambda y.  (\lambda j . \lambda k . c (j , k)) (\fst(y))(\snd(y)) \\
            &\to_{\beta} \lambda c . \lambda y.  (\lambda k . c (\fst(y) , k)) (\snd(y)) \\
            &\to_{\beta} \lambda c . \lambda y.  c (\fst(y) , \snd(y))  \\
            &\to_{\eta} \lambda c . \lambda y . c y \\
            &\to_{\eta} \lambda c . c
        \end{aligned}
    \end{equation*}
    
    Hence we clearly have
    $$
        \Gamma \vdash \mathbf{B} \mathbf{U} \mathbf{C} \equiv \lambda x . x : (A \times B \to C) \to (A \times B \to C)
    $$
\end{example}

\begin{remark}
    The previous example suggests an algorithm for deciding whether two terms are judgementally equal. Simply take the $\beta \eta$-normal form and compare terms. Since $\beta \eta$-reduction is strongly normalising, we see that equality of terms in simply typed lambda calculus is in fact decidable! [[LINK BACK TO NORMALISATION HERE]]
\end{remark}

\subsection{Swap $\lambda t . (\snd(t), \fst(t))$}

This example demonstates a simple operation that manipualtes a data structure. We will later show that composing this function with itself is the identity.

\begin{example}
    The type of $\lambda t . (\snd(t), \fst(t))$ is $A \times B \to B \times A$. Intuitively, this function simply swaps the order in an ordered pair. Here is a derivation tree showing that $\Gamma \vdash \lambda t . (\snd(t), \fst(t)) \Leftarrow B \times A \to A \times B$.

    \begin{prooftree}
        \AxiomC{$(t : A \times B) \in \Gamma , t : A \times B$}
        \LeftLabel{(var)}
        \UnaryInfC{$\Gamma , t : A \times B \vdash t \Rightarrow A \times B $}
        \LeftLabel{(cswitch)}
        \UnaryInfC{$\Gamma , t : A \times B \vdash t \Leftarrow A \times B $}
        \LeftLabel{($\times$-elim${}_2$)}
        \UnaryInfC{$\Gamma , t : A \times B \vdash \snd(t) \Rightarrow B$}
        \LeftLabel{(cswitch)}
        \UnaryInfC{$\Gamma , t : A \times B \vdash \snd(t) \Leftarrow B$}
        
        \AxiomC{$(t : A \times B) \in \Gamma , t : A \times B$}
        \RightLabel{(var)}
        \UnaryInfC{$\Gamma , t : A \times B \vdash t \Rightarrow A \times B $}
        \RightLabel{(cswitch)}
        \UnaryInfC{$\Gamma , t : A \times B \vdash t \Leftarrow A \times B $}
        \RightLabel{($\times$-elim${}_1$)}
        \UnaryInfC{$\Gamma , t : A \times B \vdash \fst(t) \Rightarrow A$}
        \RightLabel{(cswitch)}
        \UnaryInfC{$\Gamma , t : A \times B \vdash \fst(t) \Leftarrow A$}
        
        \LeftLabel{($\times$-intro)}
        \BinaryInfC{$\Gamma , t : A \times B\vdash (\snd(t), \fst(t)) \Rightarrow B \times A$}
        \LeftLabel{(cswitch)}
        \UnaryInfC{$\Gamma , t : A \times B\vdash (\snd(t), \fst(t)) \Leftarrow B \times A$}
        \LeftLabel{($\to$-intro)}
        \UnaryInfC{$\Gamma \vdash \lambda t . (\snd (t), \fst(t)) \Rightarrow B \times A$}
        \LeftLabel{(cswitch)}
        \UnaryInfC{$\Gamma \vdash \lambda t . (\snd (t), \fst(t)) \Leftarrow B \times A$}        
    \end{prooftree}
\end{exmaple}

\subsection{Swap-Swap}

We will now demonstrate that the swap function composes with itself to give the identity.

\begin{example}
    We follow a similar argument to example \ref{curry_uncurry}.
\end{example}





