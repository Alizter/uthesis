\newcommand{\tm}{\mathrm{tm}}
\newcommand{\ty}{\mathrm{ty}}

%
% Simply typed lambda calculus
%
\section{Simply typed lambda calculus} 


First develop the features needed. Discuss the arbitrary nature of such features, then use Curry-Howard as motivation for ``the language that ought to be''. Develop STLC, discuss in detail the implications, give categorical semantics. Discuss breifly the dynamics of simply typed lambda calculus. A big disadvantage of STLC over the untyped version (which we ought to discuss since we have the tools to) is that there is no recursion. There are many ways to fix this, see G\"odel for example. In order to fix this we will introduce dependent types.

We begin by discussing the syntax of our type theory. We will start by specifying the sorts $\mathcal{S}$ of our type theory.

\begin{defin}
    The sorts of simply typed lambda calculus are terms and types $\mathcal{S} := \{ \tm , \ty\}$.
\end{defin}

We now specify the operators (with generalized arities) that we defined in definition \ref{owga}. In remark \ref{opdata} we discussed the data needed to give an operator, therefore we will present all our operators in the following table.

\begin{defin}
    The operators in the syntax of simply typed lambda calculus are given by the following table:
    \begin{center}
        \begin{tabular}{ c|c|c|c|c|c|c }
        Operator & Sort & Vars & Type args & Term args & Scoping & Sugared syntax \\
        \hline
        $\to$           & \ty &  --- & $A,B$ &  ---  &  ---  & $A \to B$       \\
        $\times$        & \ty &  --- & $A,B$ &  ---  &  ---  & $A \times B$    \\
        $(-,-)$         & \tm &  --- &  ---  & $x,y$ &  ---  & $(x,y)$  \\
        $\lambda$       & \tm &  $x$ & $A,B$ &  ---  & $M$   & $\lambda (x : A).M$ \\
        $\mathrm{App}$  & \tm &  --- & $A,B$ &  ---  & $M,N$ & $M N$
        \end{tabular}
    \end{center}
\end{defin}

\begin{remark}
    Note that some of the sugared syntax loses information that was put in. The application is the main example of this. In practice if we know the type of $M$ and $N$ we can deduce the type of $M N$ just from the rules we will define later. The syntax is sugared or \emph{syntactic sugar} so we do not have to write so much. If done incorrectly it could be considered an abuse of notation. It should be possible to \emph{desugar} the syntax by adding an \emph{annotated} version of an operator. For example for application instead of $M N$ we could write $\mathrm{App}_{A,B}}(M;N)$. Having this information in the syntax will be useful when we want to induct over syntax, for example when proving an intiality theorem. But in practice we will save ourselves from having to write it out.
\end{remark}

\begin{defin}
    We can now construct our raw terms and types as the collection of abts (see definition \ref{abt}) over the previously defined data $\mathrm{Term} := \mathcal{B}[\varnothing]_{\tm}$ and $\mathrm{Type} := \mathcal{B}[\varnothing]_{\ty}$.
\end{defin}

\begin{remark}
    Note that we have no variables. This is because if we set the definition of abt up correctly we don't need any, but terms can have subterms (subtrees of the abt) which have variables. The sets $\mathrm{Term}$ and $\mathrm{Type}$ become \emph{all} the types and terms we ought to be able to write down from scratch.
\end{remark}

We now need to define judgements about our syntax and write down the rules to write them down. [[Make a note about substitution because afik we haven't defined it properly yet]]. 

\subsection{Judgements}


[[TODO: Clean up this whole paragraph(s)]]
We begin with our basic judgements. Of which there will be 5. Our STLC will have bidirectional typechecking, in that we will distinguish between the direction of type checking. There are several advantages of this and historically the two main systems called STLC are Curry's and Church's which simply differ in the direction of type checking. By having both directions and a sort of ``mode-switching rule'' we have far greater control and ease when describing type checking properties. We will also need to have a notion of \emph{judgemental equality} since we wish to do some computation. There are variations of this theme discussed in the statics chapter that allow us to have transition systems instead but we will use an equational style since transition systems can be derived from this. This also has the advantage of STLC becomming what is known as an ``equational theory''. This will be a useful feature for when we want to derrive categorical semantics. 

A context is a list of basic judgements. Our basic judgements are $x : A$. [[No it is not fix this]]

There are 5 judgements that we have:

\begin{itemize}
    \item $\Gamma \vdash A\ \mathsf{type}$ - ``$A$ is a type in context $\Gamma$''.
    \item $\Gamma \vdash T \Leftarrow A$ - ``$T$ can be checked to have type $A$ in context $\Gamma$''.
    \item $\Gamma \vdash T \Rightarrow A$ - ``$T$ synthesises the type $A$ in context $\Gamma$''.
    \item $\Gamma \vdash A \equiv B\ \mathsf{type}$ - ``$A$ and $B$ are jdugementally equal types in context $\Gamma$''.
    \item $\Gamma \vdash S \equiv T : A$ - ``$S$ and $T$ are judgementally equal terms of type $A$ in context $\Gamma$''.
\end{itemize}

\subsection{Structural rules}

Structural rules will dictate how our judgements interact with eachother, how different contexts can be formed and how substitution works. This is all roughly what a ``type theory'' ought to provide.

We begin with the \emph{variable} rule, this says that if a term $x$ appears with a type $A$ as an element in a context $\Gamma$ then $x$ synthesises a type $A$ in context $\Gamma$. Or written more succiently as:

$$
    \frac{(x:A) \in \Gamma }{\Gamma \vdash x \Rightarrow A}
$$

Other structural rules: weakening, contraction and substitution are all admissible. [[What does it mean for a rule to be admissible? We have defined this previously but we need to carefully state these facts, and prove them too!]]

\subsection{Mode-switching}

One of the features of bidirectional type checking is that we can switch the mode we are in. This is expressed as the mode switching rule:

\begin{prooftree}
    \AxiomC{$\Gamma \vdash T \Rightarrow A$}
    \AxiomC{$\Gamma \vdash A \equiv B \ \mathsf{type}$}
    \RightLabel{(switch)}
    \BinaryInfC{$\Gamma \vdash T \Leftarrow B$}
\end{prooftree}

This rule has been specially set up in that it will be the \emph{only way} to derive $\Gamma \vdash T \Leftarrow B$. [[TODO: talk more about this]]

In a unidirectional type system, the judgements $\Gamma \vdash T \Rightarrow A$ and $\Gamma \vdash T \Leftarrow B$ are collapsed into one: $\Gamma \vdash T : A$. And now the mode-switching rule may have a more familiar form:

\begin{prooftree}
    \AxiomC{$\Gamma \vdash T : A$}
    \AxiomC{$\Gamma \vdash A \equiv B \ \mathsf{type}$}
    \BinaryInfC{$\Gamma \vdash T : B$}
\end{prooftree}

Which shows that it is actually a rule about substituting along a judgemental equality! But this is a problem since a type checking algorithm will have to decide when to stop doing this. This is one of the big advantages that bidirectional type checking has over unidirectional type checking. The type checking algorithm will be simpler! [[TODO: Clean up and discuss type checking in more detail]]

\subsection{Equality rules}
Finally we have some structural rules for our two judgemental equality judgements. We wish for these to be an equivalence relation and that they are compatible with eachother.

First we begin with the structural rules for the judgement form $- \equiv -\ \mathsf{type}$:

We wish for our judgemental equality of types to be reflexive:
\begin{prooftree}
    \AxiomC{}
    \RightLabel{($\equiv_{\mathsf{type}}$-reflexivity)}
    \UnaryInfC{$\Gamma \vdash A \equiv A\ \mathsf{type}$}
\end{prooftree}

We want our judgemental equality of types to be symmetric:
\begin{prooftree}
    \AxiomC{$\Gamma \vdash A \equiv B \ \mathsf{type}$}
    \RightLabel{($\equiv_{\mathsf{type}}$-symmetry)}
    \UnaryInfC{$\Gamma \vdash B \equiv A \ \mathsf{type}$}
\end{prooftree}

and our judgemental equality of types to be transitive:

\begin{prooftree}
    \AxiomC{$\Gamma \vdash B \ \mathsf{type}$}
    \AxiomC{$\Gamma \vdash A \equiv B\ \mathsf{type}$}
    \AxiomC{$\Gamma \vdash B \equiv C\ \mathsf{type}$}
    \RightLabel{($\equiv_\mathsf{type}$-transitivity)}
    \TrinaryInfC{$\Gamma \vdash A \equiv C\ \mathsf{type}$}
\end{prooftree}

Notice how the previous rule also checks that $B$ is a type. This is because if we did not do this, we could insert any symbol in. This is clearly undesirable. It also demonstrates how subtly sensitive rules are.

Now we list the rules making the judgement form $- \equiv - : A$ into an equivalence relation:

We wish for our judgemental equality of terms to be reflexive:
\begin{prooftree}
    \AxiomC{}
    \RightLabel{($\equiv_{\mathsf{term}}$-reflexivity)}
    \UnaryInfC{$\Gamma \vdash T \equiv T : A$}
\end{prooftree}

We want our judgemental equality of terms to be symmetric:
\begin{prooftree}
    \AxiomC{$\Gamma \vdash S \equiv T : A$}
    \RightLabel{($\equiv_{\mathsf{term}}$-symmetry)}
    \UnaryInfC{$\Gamma \vdash T \equiv S : A$}
\end{prooftree}

and our judgemental equality of terms to be transitive:
\begin{prooftree}
    \AxiomC{$\Gamma \vdash T \Leftarrow A $}
    \AxiomC{$\Gamma \vdash S \equiv T : A$}
    \AxiomC{$\Gamma \vdash T \equiv R : A$}
    \RightLabel{($\equiv_{\mathsf{term}}$-transitivity)}
    \TrinaryInfC{$\Gamma \vdash S \equiv R : A$}
\end{prooftree}

as we stated before for transitivity judgemental equality of types we need to also check that the middle term $T$ is actually a term.

Finally we need a rule that will make  that judgemental equality of types and judgemental equality of terms interact the way we expect them to:
\begin{prooftree}
    \AxiomC{$\Gamma \vdash A \ \mathsf{type}$}
    \AxiomC{$\Gamma \vdash S \equiv T : A$}
    \AxiomC{$\Gamma \vdash A \equiv B\ \mathsf{type}$}
    \RightLabel{($\equiv_{\mathsf{term}}$-$\equiv_{\mathsf{type}}$-compat)}
    \TrinaryInfC{$\Gamma \vdash S \equiv T : B$}
\end{prooftree}


\subsection{Type formers}
What we have constructed thusfar is essentially an ``empty type theory''. What we have included which other authors typcially gloss over is a clean way of constructing a typechecking algorithm: bidirectional typechecking and an account of judgemental equality. We now study what are known as type formers, typically when we wish to add a new type to a type theory we need to think about a collection of rules. These can roughly be sorted into 5 kinds of rules:

\begin{itemize}
    \item Formation rules - How can I construct my type?
    \item Introduction rules - Which terms synthesise this type?
    \item Elimination rules - How can terms of this type be used?
    \item Computation (or equality) rules - How do terms of this type compute? (Normalise, etc.)
    \item Congruence rules - How do all the previous rules interact with judgemental equality
\end{itemize}

We make a note that although we will be providing all the rules, the congruence rules can be typically derrived from the others. Although we do not know exactly how to do this so we will provide them explicitly. We also note that not every type need computation rules.

Building on top of our ``empty type theory'' we introduce $\to$ the function type former:

\begin{defin}[Formation rules]

    Our formation rules tell us how to construct arrow types from other types:
    
    \begin{prooftree}
        \AxiomC{$\Gamma \vdash A\ \mathsf{type}$}
        \AxiomC{$\Gamma \vdash B\ \mathsf{type}$}
        \RightLabel{($\to$-form)}
        \BinaryInfC{$\Gamma \vdash A \to B \ \mathsf{type}$}
    \end{prooftree}

\end{defin}

\begin{defin}[Introduction rules]

    Our introduction rule tells us how to construct terms of our type. This is also known as $\lambda$-abstraction:

    \begin{prooftree}
        \AxiomC{$\Gamma , x : A\vdash M \Leftarrow B$}
        \RightLabel{($\to$-intro)}
        \UnaryInfC{$\Gamma \vdash \lambda x . M \Rightarrow A \to B$}
    \end{prooftree}

\end{defin}

\begin{defin}[Elimination rules]

    Our elimination rule tells us how to use terms of this type. For function types this corresponds to application:

    \begin{prooftree}
        \AxiomC{$\Gamma \vdash M \Leftarrow A \to B$}
        \AxiomC{$\Gamma \vdash N \Leftarrow A$}
        \RightLabel{($\to$-elim)}
        \BinaryInfC{$\Gamma \vdash M N \Rightarrow B$}
    \end{prooftree}

\end{defin}

\begin{defin}[Computation rules]

    And finally we have computation rules which tell us how to compute our terms. We will later prove results about normalisation of the lambda calculus. We start with $\beta$-reduction which tells us how applicated functions compute:

    \begin{prooftree}
        \AxiomC{$\Gamma , x : A \vdash y : B$}
        \AxiomC{$\Gamma \vdash t : A$}
        \RightLabel{($\to$-$\beta$)}
        \BinaryInfC{$\Gamma \vdash (\lambda x . y) t \equiv y[t / x] : B$}
    \end{prooftree}

    Then we introduce $\eta$-conversion which tells us if two functions applied to the same term and are judgementally equal then the functions are judgementally equal. This is ``functional extensionality'' for judgemental equality.

    \begin{prooftree}
        \AxiomC{$\Gamma , y : A \vdash M y \equiv M' y : B$}
        \RightLabel{($\to$-$\eta$)}
        \UnaryInfC{$\Gamma \vdash M \equiv M' : A \to B$}
    \end{prooftree}

\end{defin}

\begin{defin}[{Congruence rules]

    Finally we have to make sure all our rules respect judgemental equality. This means showing that $\to$ respects judgemental equality of types and that $\lambda$-terms and applications respect judgemental equality of terms.

    \begin{prooftree}
        \AxiomC{$\Gamma \vdash A \equiv A' \ \mathsf{type}$}
        \AxiomC{$\Gamma \vdash B \equiv B' \ \mathsf{type}$}
        \RightLabel{($\to$-$\equiv_{\mathsf{type}}$-cong)}
        \BinaryInfC{$\Gamma \vdash A \to B \equiv A' \to B' \ \mathsf{type}$}
    \end{prooftree}

    \begin{prooftree}
        \AxiomC{$\Gamma , x : A \vdash M \equiv M' : B$}
        \RightLabel{($\to$-$\equiv_{\mathsf{term}}$-cong)}
        \UnaryInfC{$\Gamma \vdash \lambda x . M \equiv \lambda x . M' : A \to B$}
    \end{prooftree}

    \begin{prooftree}
        \AxiomC{$\Gamma \vdash M \equiv M' : A \to B$}
        \AxiomC{$\Gamma \vdash N \equiv N' : A$}
        \RightLabel{($\to$-elim-cong)}
        \BinaryInfC{$\Gamma \vdash M N \equiv M' N' : A \to B$}
    \end{prooftree}

\end{defin}

We define the product type as follows.

\begin{defin}[Product type]
    
    Given two types, we have their product type:
    
    \begin{prooftree}
        \AxiomC{$\Gamma \vdash A \ \mathsf{type}$}
        \AxiomC{$\Gamma \vdash B \ \mathsf{type}$}
        \RightLabel{($\times$-form)}
        \BinaryInfC{$\Gamma \vdash A \times B \ \mathsf{type}$}
    \end{prooftree}
    
    We define ordered pairs as taking a term of each type:
    
    \begin{prooftree}
        \AxiomC{$\Gamma \vdash a \Leftarrow A$}
        \AxiomC{$\Gamma \vdash b \Leftarrow B$}
        \RightLabel{($\times$-intro)}
        \BinaryInfC{$\Gamma \vdash (a, b) \Rightarrow A \times B$}
    \end{prooftree}
    
    We given an eliminator for the product type. Which is going to be uncurrying. This is equivalent to giving two ``accessor'' functions that project.
    
    \begin{prooftree}
        \AxiomC{$\Gamma \vdash f \Leftarrow A \to (B \to C)$}
        \RightLabel{($\times$-elim)}
        \UnaryInfC{$\Gamma \vdash \mathrm{ind}_{A \times B}(f) \Rightarrow A \times B \to C$}
    \end{prooftree}

    And we finally need to dictate how this is computed:
    
    \begin{prooftree}
        \AxiomC{$\Gamma \vdash a \Leftarrow A$}
        \AxiomC{$\Gamma \vdash b \Leftarrow B$}
        \AxiomC{$\Gamma \vdash f \Leftarrow A \to (B \to C)$}
        \RightLabel{($\times$-$\beta$)}
        \TrinaryInfC{$\Gamma \vdash \mathrm{ind}_{A\times B}(f) (a, b) \equiv f(a)(b) : C $}
    \end{prooftree}
    
    We will sometimes talk about the first and second elements of a pair, so it can be convenient to introduce the following functions with names. But we will not really consider this as part of the type theory, more rather a feature. There are various ways to formalise what we have done here, usually going by the name of a let statement or something.
    
    \begin{prooftree}
        \AxiomC{}
        \UnaryInfC{$\Gamma \vdash \mathrm{fst} \equiv \mathrm{ind}_{A \times B}(\lambda x . (\lambda y . x)) : A \times B \to C$} 
    \end{prooftree}
    
    \begin{prooftree}
        \AxiomC{}
        \UnaryInfC{$\Gamma \vdash \mathrm{snd} \equiv \mathrm{ind}_{A \times B}(\lambda x . (\lambda y . y)) : A \times B \to C$}
    \end{prooftree}
    
    It can be shown that $ a : A, b : B \vdash \mathrm{fst}(a, b)\equiv a : A$ and $a : A, b : B \vdash \mathrm{snd}(a, b)\equiv b : B$. [[However I am not so sure that $t : A \times B \vdash (\mathrm{fst}(t), \mathrm{snd}(t)) \equiv t : A \times B$... Maybe ($\times$-$\eta$) or something needs to be added]]
\end{defin}

We will also need to add a unit type. This will be the simplest type, with only one term.

\begin{defin}[Unit type]

    We begin with the formation rules, essentially saying that the unit type exists.

    \begin{prooftree}
        \AxiomC{}
        \RightLabel{($\mathbf{1}$-form)}
        \UnaryInfC{$\mathbf{1}\ \mathsf{type}$}
    \end{prooftree}

    We then say that the unit type has a term:

    \begin{prooftree}
        \AxiomC{}
        \RightLabel{($\mathbf{1}$-intro)}
        \UnaryInfC{$\Gamma \vdash * \Rightarrow \mathbf{1}$}
    \end{prooftree}
    
    Next we specifiy that in order to create a function out of the unit type, it suffices to give a term $a : A$. This function is then called $\mathrm{ind}_{\mathbf{1}}(a) : \mathbf{1} \to A$.
    
    \begin{prooftree}
        \AxiomC{$\Gamma \vdash a : A$}
        \RightLabel{($\mathbf{1}$-elim)}
        \UnaryInfC{$\Gamma \vdash \mathrm{ind}_{\mathbf{1}}(a) \Rightarrow \mathbf{1} \to A$}
    \end{prooftree}

    Next we show how this function computes, which is that for any $x \Leftarrow \mathbf{1}$ (of which there are not many) we have it being judgementally equal to $a : A$.
    
    \begin{prooftree}
        \AxiomC{$\Gamma vdash x \Leftarrow \mathbf{1}$}
        \RightLabel{($\mathbf{1}$-comp)}
        \UnaryInfC{$\Gamma \vdash \mathrm{ind}_{\mathbf{1}}(a) x \equiv a : A$}
    \end{prooftree}

\end{defin}

[[TODO: Clear up wording maybe?]]
\begin{remark}
    We make an important note that this is not the simplest presentation of the STLC of which there are many variations thereof. We chose judgemental equality and bidirectional type checking because these are features we will need if we are to enrich our type system with dependent types.
\end{remark}

\subsection{Inversion lemmas}
Having listed all these rules we need some lemmas detailing how different terms can \emph{only} come from a set of specified rules. This is a crucial analysis if we wish to construct a type checking algorithm. An inversion lemma for a type theory is typically very difficult to state, and extremely tedious to prove. But nontheless is essential if we want to induct over terms.

[[TODO: State this beast]]
\begin{lemma}
    In the STLC the following term forms are generated by certain rules...
\end{lemma}

\subsection{Normalisation and Canonicity}

[[These two concepts are very related, we should find some way to talk about it, including Church-Rosser]]

\subsection{Examples of lambda terms}

Untyped lambda calculus, as we mentioned, is in fact \emph{stronger} than the typed lambda calculus. This we will see by looking at some examples of type checking. Many of these are combinators from untyped lambda calculus in combinatory logic. \ref{} [[Need refereence of Mockingbird combinator thing]]

Note we don't have very much choice on types, so it may be useful to enrich our type theory with $+$-types or even the natural numbers. But we will see soon that these both are special cases of dependent types.

\begin{example}[Identity function]
    Let's consider the following lambda term $\lambda x . x$. We wish to find a type $T$ such that given some context $\Gamma$ we have $\Gamma \vdash \lambda x . x \Leftarrow T$. Our inversion lemma will tell us exactly which rules let us get to this point. So we will essentially be performing a tree search. Firstly we need to switch modes to get $\lambda x . x \Rightarrow T$. But mode switching also lets us change our 
    \begin{prooftree}
        \AxiomC{$\Gamma \vdash \lambda x . x \Rightarrow T$}
    \end{prooftree}
\end{example}

\begin{example}
    Here is another example of a term that type checks. Unfortunately we see the disadvantage with type-setting derivation trees: they are very difficult to write down, and get really wide very quickly.  We want to find a type $T$ such that $\Gamma \vdash \lambda x . \lambda y . x y \Leftarrow T$ is true. Here is a derivation tree: 
        \begin{landscape}
            \centering
            \vspace*{\fill}
            \begin{prooftree}
                %\rootAtTop
                \def\ScoreOverhang{1pt}
                %%%
                \AxiomC{$x : A \in \Gamma , x : A, y : C$}
                \LeftLabel{(var)}
                \UnaryInfC{$\Gamma , x : A, y : C \vdash x \Rightarrow A$}
                \AxiomC{}
                \RightLabel{$(***)$}
                \UnaryInfC{$\Gamma , x : A, y : C \vdash C \to D \equiv A \ \mathsf{type}$}
                    %\insertBetweenHyps{\hskip -5pt}
                \BinaryInfC{$\Gamma , x : A, y : C \vdash x \Leftarrow C \to D$}
                \AxiomC{}
                \RightLabel{$(\dagger)$}
                \UnaryInfC{$\Gamma , x : A, y : C \vdash y \Leftarrow C$}
                \LeftLabel{($\to$-elim)}                
                    \insertBetweenHyps{\hskip -20pt}
                \BinaryInfC{$\Gamma , x : A, y : C \vdash x y \Rightarrow D$}
                \AxiomC{}
                \RightLabel{($\equiv_{\mathsf{type}}$-refl)}
                \UnaryInfC{$\Gamma , x : A, y : C \vdash D \equiv D\ \mathsf{type}$}
                \LeftLabel{(switch)}
                    %\insertBetweenHyps{\hskip -10pt}
                \BinaryInfC{$\Gamma , x : A , y : C \vdash xy \Leftarrow D$}
                \LeftLabel{($\to$-intro)}
                \UnaryInfC{$\Gamma , x : A \vdash \lambda y . x y \Rightarrow C \to D$}
                \AxiomC{}
                \RightLabel{$(**)$}
                \UnaryInfC{$\Gamma , x : A \vdash B \equiv C \to D \ \mathsf{type}$}
                \LeftLabel{(switch)}
                    \insertBetweenHyps{\hskip -150pt}
                \BinaryInfC{$ \Gamma , x : A \vdash \lambda y . xy \Leftarrow B$}
                \LeftLabel{($\to$-intro)}
                \UnaryInfC{$\Gamma \vdash \lambda x . \lambda y . x y \Rightarrow A \to B$}
                \AxiomC{}
                \RightLabel{$(*)$}
                \UnaryInfC{$\Gamma \vdash T \equiv A \to B \ \mathsf{type}$}
                \LeftLabel{(switch)}
                    \insertBetweenHyps{\hskip -90pt}
                \BinaryInfC{$\Gamma \vdash \lambda x . \lambda y . x y \Leftarrow T$}
            \end{prooftree}
            \vfill
        \end{landscape}
        
        \begin{proof}
        We begin with the judgement $\Gamma \vdash \lambda x . \lambda y . x y \Leftarrow T$, now the only way to arrive at this judgement is via the mode-switching rule. Whilst doing this we add type variables $A$ and $B$ which can easily be seen to form into $A \to B$ and let $T \equiv A \to B$. We can come back later and validate this judgement. The mode-switching should have given us $\Gamma \vdash \lambda x . \lambda y . x y \Rightarrow A \to B$ which we can only arrive at by applying the ($\to$-intro) rule. This gives us $\Gamma , x : A \vdash \lambda y . xy \Leftarrow B$. Which we have to mode-switch, and as before we take this chance to introduce type variables $C$ and $D$ in order to arrive at the judgement $\Gamma , x : A \vdash \lambda y . x y \Rightarrow C \to D$. This allows us to apply ($\to$-intro) giving us $\Gamma , x : A , y : C \vdash xy \Leftarrow D$. Now we apply the ($\to$-elim) rule since we have an application. For this we need $\Gamma , x : A, y : C \vdash y \Leftarrow C$, which is marked as $(\dagger)$, and observe that a simple application of mode-switching and the variable rule allows us to derive this judgement. The other hypthesis we need is $\Gamma , x : A, y : C \vdash x \Leftarrow C \to D$. Again by mode-switching and setting $C \to D \equiv A$ we get $\Gamma , x : A, y : C \vdash x \Rightarrow A$ which is clearly derivable by the variable rule. 
        
        
        Now we have 3 type equations $(*)$, $(**)$ and $(***)$, substituting back in we get $\Gamma \vdash T \equiv (C \to D) \to C \to D$ for some types $C$ and $D$. So $\Gamma \vdash \lambda x . \labmda y . x y \Leftarrow T$ if we have types $C$ and $D$.
        \end{proof}
\end{example}

\begin{remark}
    There is a lot going on the the previous example, but crucially it should be observed that it is in fact the \emph{inversion lemmas} that allow us to make choices of which rules to use. So a type-checking algorithm would have to make choices based on what the inversion lemmas say. We also introduced equalities of types which was brushed over. In general, type equalities are only generated by reflexivity so in a way our equations were lifted to equality of syntax. This gave us a classical equality problem. Since all our syntax are trees, we can easily decide their equality. [[CAN YOU???!!]]
\end{remark}


\begin{comment}
%\subsection{Lambda calculus}
%We recall that there are 3 kinds of expressions in lambda calculus: variables, abstractions and applications. These are defined inductively on themselves. A variable is simply a string of characters from an alphabet. A lambda abstraction looks like $\lambda x.y$ where $x$ is some variable and $y$ is some expression. There are alternate ways of writing this, allowing us to drop the need for naming $x$, for example de Brujin indices. Finally an application is simply the concatenation $ab$ of two expressions $a$ and $b$. We will assume that  This fully describes the syntax of this type theory. We will now introduce some rules that tell us which expressions we can derive from other expressions. Firstly we have $\beta$-reduction which tells us if we have an expression of the form $(\lambda x . y)z$ this can be reduced to an expression where all occurrences of $x$ in $y$ are replaced with the expression $z$. We also have $\alpha$-conversion which I would argue isn't really a rule as naming of variables can be completely avoided in the first place using de Brujin indices or even combinators. \cite{BarendregtHenk2013Lcwt, hottbook}

%\subsection{Contexts}
%In mathematics we work with contexts implicitly. That is there is always an ambient knowledge of what has been defined. Mostly due to the nature of how we read mathematical papers. We can make this explicit using contexts. We will not however, use contexts in our discussion of type theory but we will provide a formal exposition in the appendix.

\subsection{Judgements}
Our judgements:
\begin{center}
    \begin{tabular}{c | c}
        $\Gamma\ \mathrm{ctx}$ &  $\Gamma$ is a well-formed context. \\
        $\Gamma \vdash A\ \mathrm{Type}$ & $A$ is a type in context $\Gamma$. \\
        $\Gamma \vdash x : A$ & $x$ is a term of type $A$ in context $\Gamma$. \\
%        $\Gamma \vdash x \equiv y : A$ & the terms $x$ and $y$ of type $A$ are definitionally equal in context $\Gamma$
    \end{tabular}
\end{center}


Type theory ``will be about'' deriving judgements from other judgements. Which can be concisely summarised in the form of an inference rule

$$\frac{A_1\quad A_2 \quad \cdots \quad A_n}{B}$$

which says that given the judgements $A_1,\dots,A_n$ we can derive the judgement $B$.

\subsection{Structural rules}
We now look at the rules that govern contexts and the structure of our type system.

We begin with a rule stating that the empty context (which as contexts are sets or lists is well-defined) is well-formed. Which is another way of stating that the context was grown in a specified way and is not just an arbitrary list or set of variables.

\begin{prooftree}
    \AxiomC{}
    \RightLabel{empty-ctx}
    \UnaryInfC{$\varnothing$ ctx}
    \singleLine
\end{prooftree}

We also want the concatenation of two well-formed contexts to be well-formed.

\begin{prooftree}
    \AxiomC{$\Gamma$ ctx}
    \AxiomC{$\Delta$ ctx}
    \BinaryInfC{$\Gamma,\Delta$ ctx}
\end{prooftree}

We omit rules about repeating or removing repeated elements and ordering lists (think of them as finite sets).

A variable is a statement of the form $x : A$ where $x$ is known as the term and $A$ its type.

\subsection{Function types}

We introduce a formation rule for the function type.

\begin{prooftree}
    \RightLabel{$(\to)$-form}
    \AxiomC{$\Gamma \vdash A\ \mathrm{Type}$}
    \AxiomC{$\Gamma \vdash B\ \mathrm{Type}$}
    \BinaryInfC{$\Gamma \vdash A \to B\ \mathrm{Type}$}
\end{prooftree}

We now need a rule for producing terms of this new type. We introduce the introduction rule for the function type.

\begin{prooftree}
    \RightLabel{$(\to)$-intro}
    \AxiomC{$\Gamma, x : A \vdash y : B$}
    \UnaryInfC{$\Gamma \vdash (\lambda x . y) : A \to B$}
\end{prooftree}

We will sometimes call this lambda abstraction. We next introduce a way to apply these functions to terms in their domains. We introduce our elimination rule for the function type.

\begin{prooftree}
    \RightLabel{$(\to)$-elim}
    \AxiomC{$\Gamma \vdash f : A \to B$}
    \AxiomC{$\Gamma \vdash a : A$}
    \BinaryInfC{$\Gamma \vdash f(a) : B$}
\end{prooftree}

This is essentially useless unless we have a way to compute (or reduce) this expression. This is where our computation rule comes in. The computation rule will tell us how our elimination rule and introduction rule interact.
\begin{prooftree}
    \RightLabel{$(\to)$-comp}
    \AxiomC{$(\lambda x . y) : A \to B$}
    \AxiomC{$\Gamma, a : A \vdash (\lambda x.y)a : B$}
    \AxiomC{$\Gamma, x : A, y : B, (\lambda x . y) : A \to B, a : A \vdash (\lambda x . y) (a) : B$}
    \UnaryInfC{$\Gamma \vdash y[x / a] : B$}
\end{prooftree}

%%%%%%%%%%%%%%%%%%%%

We will describe what is known as a simply typed lambda calculus. There is a lot of literature on type theory, and it doesn't seem that there are many authors in agreement of ways to present it.

In \cite{BarendregtHenk2013Lcwt} a more type theoretic approach, analysing the type theory mostly in the syntactic world. This gives us a good starting point for how we want our type theory to be presented however it may not be so easy to keep an eye on how the categorical semantics (the ways we model types in mathematics) behave. In order to do this we will use references such as \cite{CroleRoyL1993Cft, JacobsCLTT, LambekJ1986Itho}. This will be from the more categorical logic school of thought, which will study type theory that is "generated" by certain categories in interest.

We start by describing a general class of simple type theories as outlined in \cite{JacobsCLTT}. Firstly we introduce the notion of a {\it signature}. Similar accounts can be found in \cite{CroleRoyL1993Cft}. This will essentially consist of "generating" a category from some signature (which can be thought of as a stripped down type theory syntax), and then studying the functors from that category into other categories. This allows nice properties from the second category to be "pulled back" onto our type theory giving it features we desire.

\begin{defin}
	A {\bf signature} is a pair $(\Typ, \mathcal{F})$ where $\Typ$ is a finite set of {\bf basic} (or {\bf atomic}) {\bf types}. And a functor $\mathcal{F} : \Typ^\star \times \Typ \to \Set$. Where $\Typ^\star$ is the Kleene-Star operation on a set (or the free monoid over $\Typ$), defined as $X^\star := \bigcup_{n\in \N} X^n$ whose elements are finite tuples of elements of $X$ for a set $X$. We have $\mathbf{Set}$ for the category of finite sets. Note that the sets in the domain of the functor are realised as discrete categories.
\end{defin}

We will usually write a signature as $\Sigma := (\Typ, \mathcal{F})$, denote $|\Sigma|:=\Typ$ and write $F: \sigma_1,\dots,\sigma_n\to\sigma_{n+1}$ when $F \in \mathcal{F}(( \sigma_1,\dots,\sigma_n ), \sigma_{n+1})$.

\begin{defin}
    Let $\Var$ be a countable set. Elements $x\in \Var$ are called {\bf variables}.
\end{defin}

Note this style of variables is essentially de Brujin indices. But allows us to have a set of names for our variables, which allows future annoyances like $\alpha$-equivalence to be sorted out easily due to the plentiful existence of bijections from $\Var \to \Var$.

\begin{defin}
	A {\bf variable declaration} is a pair $(x, \sigma) \in \Var \times \Typ$ usually written as $x : \sigma$. This can be read as "the variable $x$ has type $\sigma$. We will define $\Dec:=\Var \times \Typ$.
\end{defin}

\begin{defin}
    A {\bf context} $\Gamma$ is an element of $\Con:=\Dec^\star$. In other words, a context is a finite list of variable declarations. We will usually write a context $\Gamma$ as $v_1 : \sigma_1, \dots ,v_n : \sigma_n$. Note that the Kleene-Star has a monoid structure with operation $","$. We can thus give $\Con$ a monoid structure and write, for contexts $\Gamma$ and $\Delta$ another context $\Gamma,\Delta$ which is the concatenation of two contexts. The notation here allows the "expanded version" to coincide, as in $\Gamma,\Delta$ can be written as $v_1 : \sigma_1, \dots ,v_n : \sigma_n, w_1 : \tau_1, \dots, w_m, \tau_m$.
\end{defin}

We also note that there is a canonical inclusion $\Dec \hookrightarrow \Con$ given that $\Dec$ freely generates the monoid $\Con$. This will allow us to write $\Gamma, x:\tau$ for $v_1 : \sigma_1, \dots ,v_n : \sigma_n, x:\tau$.

We now denote the basic statements of our language. These statements are called {\bf judgements} and we will derive

%%%%%%%%%%%%%%%%%%%%
\end{comment}







