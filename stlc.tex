\newcommand{\tm}{\mathrm{tm}}
\newcommand{\ty}{\mathrm{ty}}
\newcommand{\fst}{\mathrm{fst}}
\newcommand{\snd}{\mathrm{snd}}

%
% Simply typed lambda calculus
%
\section{Simply typed lambda calculus} 


First develop the features needed. Discuss the arbitrary nature of such features, then use Curry-Howard as motivation for ``the language that ought to be''. Develop STLC, discuss in detail the implications, give categorical semantics. Discuss briefly the dynamics of simply typed lambda calculus. A big disadvantage of STLC over the untyped version (which we ought to discuss since we have the tools to) is that there is no recursion. There are many ways to fix this, see G\"odel for example. In order to fix this we will introduce dependent types.

We begin by discussing the syntax of our type theory. We will start by specifying the sorts $\mathcal{S}$ of our type theory.

\begin{defin}
    The sorts of simply typed lambda calculus are terms and types $\mathcal{S} := \{ \tm , \ty\}$.
\end{defin}

We now specify the operators (with generalised arities) that we defined in definition \ref{owga}. In remark \ref{opdata} we discussed the data needed to give an operator, therefore we will present all our operators in the following table.

\begin{defin}
    The operators in the syntax of simply typed lambda calculus are given by the following table:
    \begin{center}
        \begin{tabular}{ c|c|c|c|c|c|c }
        Op & Sort & Vars & Type args & Term args & Scoping & Syntax \\
        \hline
        $\to$           & \ty &  --- & $A,B$ &  ---  &  ---  & $A \to B$            \\
        $\times$        & \ty &  --- & $A,B$ &  ---  &  ---  & $A \times B$         \\
        $(-,-)$         & \tm &  --- &  ---  & $x,y$ &  ---  & $(x,y)$              \\
        $\lambda$       & \tm &  $x$ & $A,B$ &  ---  &  $M$  & $\lambda (x : A).M$  \\
        $\mathrm{App}$  & \tm &  --- & $A,B$ &  ---  & $M,N$ & $M N$
        \end{tabular}
    \end{center}
\end{defin}

\begin{remark}
    Note that some of the syntax loses information that was put in. The application is the main example of this. In practice if we know the type of $M$ and $N$ we can deduce the type of $M N$ just from the rules we will define later. The syntax is sugared or \emph{syntactic sugar} so we do not have to write so much. If done incorrectly it could be considered an abuse of notation. It should be possible to \emph{desugar} the syntax by adding an \emph{annotated} version of an operator. For example for application instead of $M N$ we could write $\mathrm{App}_{A,B}}(M;N)$. Having this information in the syntax will be useful when we want to induct over syntax, for example when proving an initiality theorem. But in practice we will save ourselves from having to write it out.
\end{remark}

\begin{defin}
    We can now construct our raw terms and types as the collection of abts (see definition \ref{abt}) over the previously defined data $\mathrm{Term} := \mathcal{B}[\varnothing]_{\tm}$ and $\mathrm{Type} := \mathcal{B}[\varnothing]_{\ty}$.
\end{defin}

\begin{remark}
    Note that we have no variables. This is because if we set the definition of abt up correctly we don't need any, but terms can have sub-terms (sub-trees of the abt) which have variables. The sets $\mathrm{Term}$ and $\mathrm{Type}$ become \emph{all} the types and terms we ought to be able to write down from scratch.
\end{remark}

We now need to define judgements about our syntax and write down the rules to write them down. [[Make a note about substitution because afik we haven't defined it properly yet]]. 

\subsection{Judgements}


[[TODO: Clean up this whole paragraph(s)]]
We begin with our basic judgements. Of which there will be 5. Our STLC will have bidirectional type checking, in that we will distinguish between the direction of type checking. There are several advantages of this and historically the two main systems called STLC are Curry's and Church's which simply differ in the direction of type checking. By having both directions and a sort of ``mode-switching rule'' we have far greater control and ease when describing type checking properties. We will also need to have a notion of \emph{judgemental equality} since we wish to do some computation. There are variations of this theme discussed in the statics chapter that allow us to have transition systems instead but we will use an equational style since transition systems can be derived from this. This also has the advantage of STLC becoming what is known as an ``equational theory''. This will be a useful feature for when we want to derive categorical semantics. 

A context is a list of basic judgements. Our basic judgements are $x : A$. [[No it is not fix this]]

There are 5 judgements that we have:

\begin{itemize}
    \item $\Gamma \vdash A\ \mathsf{type}$ - ``$A$ is a type in context $\Gamma$''.
    \item $\Gamma \vdash T \Leftarrow A$ - ``$T$ can be checked to have type $A$ in context $\Gamma$''.
    \item $\Gamma \vdash T \Rightarrow A$ - ``$T$ synthesises the type $A$ in context $\Gamma$''.
    \item $\Gamma \vdash A \equiv B\ \mathsf{type}$ - ``$A$ and $B$ are judgmentally equal types in context $\Gamma$''.
    \item $\Gamma \vdash S \equiv T : A$ - ``$S$ and $T$ are judgmentally equal terms of type $A$ in context $\Gamma$''.
\end{itemize}

\subsection{Structural rules}

Structural rules will dictate how our judgements interact with each other, how different contexts can be formed and how substitution works. This is all roughly what a ``type theory'' ought to provide.

\begin{defin}
    We begin with the \emph{variable} rule, this says that if a term $x$ appears with a type $A$ as an element in a context $\Gamma$ then $x$ synthesises a type $A$ in context $\Gamma$. Or written more succinctly as:

    % Variable rule
    \begin{prooftree}
        \AxiomC{$(x:A) \in \Gamma$}
        \RightLabel{(var)}
        \UnaryInfC{$\Gamma \vdash x \Rightarrow A$}
    \end{prooftree}
\end{defin}

Other structural rules: weakening, contraction and substitution are all admissible. [[What does it mean for a rule to be admissible? We have defined this previously but we need to carefully state these facts, and prove them too!]]

\end{defin}
    One of the features of bidirectional type checking is that we can switch the mode we are in. This is expressed as the mode switching rule:

    % Switch rule
    \begin{prooftree}
        \AxiomC{$\Gamma \vdash t \Rightarrow A$}
        \AxiomC{$\Gamma \vdash A \equiv B \ \mathsf{type}$}
        \RightLabel{(cswitch)}
        \BinaryInfC{$\Gamma \vdash t \Leftarrow B$}
    \end{prooftree}
\end{defin}

\begin{remark}
    This rule has been specially set up in that it will be the \emph{only way} to derive $\Gamma \vdash T \Leftarrow B$. These are the kinds of properties we would like our syntax to have. A careful analysis will be done under the name of \emph{inversion lemma}. [[Link to inversion lemma?]]

    In a unidirectional type system, the judgements $\Gamma \vdash T \Rightarrow A$ and $\Gamma \vdash T \Leftarrow B$ are collapsed into one: $\Gamma \vdash T : A$. And now the mode-switching rule may have a more familiar form:

    \begin{prooftree}
        \AxiomC{$\Gamma \vdash t : A$}
        \AxiomC{$\Gamma \vdash A \equiv B \ \mathsf{type}$}
        \BinaryInfC{$\Gamma \vdash t : B$}
    \end{prooftree}

    Which shows that it is actually a rule about substituting along a judgemental equality! But this is a problem since a type checking algorithm will have to decide when to stop doing this. This is one of the big advantages that bidirectional type checking has over unidirectional type checking. The type checking algorithm will be simpler! [[TODO: Clean up and discuss type checking in more detail]]
\end{remark}

\begin{remark}
    Occasionally, we will simply mode-switch using reflexivity $\Gamma \vdash A \equiv A \ \mathsf{type}$, in which case we will abbreviate the rule as follows:
    % compact switch
    \begin{prooftree}
        \AxiomC{$\Gamma \vdash t \Rightarrow A$}
        \RightLabel{(switch)}
        \UnaryInfC{$\Gamma \vdash t \Leftarrow A$}
    \end{prooftree}
\end{remark}

\subsection{Equality rules}
Finally we have some structural rules for our two judgemental equality judgements. We wish for these to be an equivalence relation and that they are compatible with each other.

First we begin with the structural rules for the judgement form $- \equiv -\ \mathsf{type}$:

\begin{defin}

    % Reflexivity of judgemental equality of types
    We wish for our judgemental equality of types to be reflexive:
    \begin{prooftree}
        \AxiomC{$\Gamma \vdash A \ \mathsf{type}$}
        \RightLabel{($\equiv_{\mathsf{type}}$-reflexivity)}
        \UnaryInfC{$\Gamma \vdash A \equiv A\ \mathsf{type}$}
    \end{prooftree}

    % Symmetry of judgemental equality of types
    We want our judgemental equality of types to be symmetric:
    \begin{prooftree}
        \AxiomC{$\Gamma \vdash A \equiv B \ \mathsf{type}$}
        \RightLabel{($\equiv_{\mathsf{type}}$-symmetry)}
        \UnaryInfC{$\Gamma \vdash B \equiv A \ \mathsf{type}$}
    \end{prooftree}

    and our judgemental equality of types to be transitive:

    % Transitivity of judgemental equality of types
    \begin{prooftree}
        \AxiomC{$\Gamma \vdash B \ \mathsf{type}$}
        \AxiomC{$\Gamma \vdash A \equiv B\ \mathsf{type}$}
        \AxiomC{$\Gamma \vdash B \equiv C\ \mathsf{type}$}
        \RightLabel{($\equiv_\mathsf{type}$-transitivity)}
        \TrinaryInfC{$\Gamma \vdash A \equiv C\ \mathsf{type}$}
    \end{prooftree}

    Notice how the previous rule also checks that $B$ is a type. This is because if we did not do this, we could insert any symbol in. This is clearly undesirable. It also demonstrates how subtly sensitive rules are.

    Now we list the rules making the judgement form $- \equiv - : A$ into an equivalence relation:

    % Reflexivity of judgemental equality of terms
    We wish for our judgemental equality of terms to be reflexive:
    \begin{prooftree}
        \AxiomC{$\Gamma \vdash t \Leftarrow A$}
        \RightLabel{($\equiv_{\mathsf{term}}$-reflexivity)}
        \UnaryInfC{$\Gamma \vdash t \equiv t : A$}
    \end{prooftree}

    % Symmetry of judgemental equality of terms
    We want our judgemental equality of terms to be symmetric:
    \begin{prooftree}
        \AxiomC{$\Gamma \vdash s \equiv t : A$}
        \RightLabel{($\equiv_{\mathsf{term}}$-symmetry)}
        \UnaryInfC{$\Gamma \vdash t \equiv s : A$}
    \end{prooftree}

    % Transitivity of judgemental equality of terms
    and our judgemental equality of terms to be transitive:
    \begin{prooftree}
        \AxiomC{$\Gamma \vdash t \Leftarrow A $}
        \AxiomC{$\Gamma \vdash s \equiv t : A$}
        \AxiomC{$\Gamma \vdash t \equiv r : A$}
        \RightLabel{($\equiv_{\mathsf{term}}$-transitivity)}
        \TrinaryInfC{$\Gamma \vdash s \equiv r : A$}
    \end{prooftree}

    as we stated before for transitivity judgemental equality of types we need to also check that the middle term $T$ is actually a term.

    % judgemental equality of types - judgemental equality of terms - congruence
    Finally we need a rule that will make  that judgemental equality of types and judgemental equality of terms interact the way we expect them to:
    \begin{prooftree}
        \AxiomC{$\Gamma \vdash A \ \mathsf{type}$}
        \AxiomC{$\Gamma \vdash s \equiv t : A$}
        \AxiomC{$\Gamma \vdash A \equiv B\ \mathsf{type}$}
        \RightLabel{($\equiv_{\mathsf{term}}$-$\equiv_{\mathsf{type}}$-compat)}
        \TrinaryInfC{$\Gamma \vdash s \equiv t : B$}
    \end{prooftree}
\end{defin}

\subsection{Type formers}
What we have constructed thus far is essentially an ``empty type theory''. What we have included which other authors typically gloss over is a clean way of constructing a type checking algorithm: bidirectional type checking and an account of judgemental equality. We now study what are known as type formers, typically when we wish to add a new type to a type theory we need to think about a collection of rules. These can roughly be sorted into 5 kinds of rules:

\begin{itemize}
    \item Formation rules - How can I construct my type?
    \item Introduction rules - Which terms synthesise this type?
    \item Elimination rules - How can terms of this type be used?
    \item Computation (or equality) rules - How do terms of this type compute? (Normalise, etc.)
    \item Congruence rules - How do all the previous rules interact with judgemental equality
\end{itemize}

We make a note that although we will be providing all the rules, the congruence rules can be typically derived from the others. Although we do not know exactly how to do this so we will provide them explicitly. We also note that not every type need computation rules.

Building on top of our ``empty type theory'' we introduce $\to$ the function type former:

\begin{defin}

    Our formation rules tell us how to construct arrow types from other types:
    
    % -> formation
    \begin{prooftree}
        \AxiomC{$\Gamma \vdash A\ \mathsf{type}$}
        \AxiomC{$\Gamma \vdash B\ \mathsf{type}$}
        \RightLabel{($\to$-form)}
        \BinaryInfC{$\Gamma \vdash A \to B \ \mathsf{type}$}
    \end{prooftree}

    Our introduction rule tells us how to construct terms of our type. This is also known as $\lambda$-abstraction:

    % -> introduction
    \begin{prooftree}
        \AxiomC{$\Gamma , x : A\vdash M \Leftarrow B$}
        \RightLabel{($\to$-intro)}
        \UnaryInfC{$\Gamma \vdash \lambda x . M \Rightarrow A \to B$}
    \end{prooftree}

    Our elimination rule tells us how to use terms of this type. For function types this corresponds to application:

    % -> elimination
    \begin{prooftree}
        \AxiomC{$\Gamma \vdash M \Leftarrow A \to B$}
        \AxiomC{$\Gamma \vdash N \Leftarrow A$}
        \RightLabel{($\to$-elim)}
        \BinaryInfC{$\Gamma \vdash M N \Rightarrow B$}
    \end{prooftree}

    And finally we have computation rules which tell us how to compute our terms. We will later prove results about normalisation of the lambda calculus. We start with $\beta$-reduction which tells us how applied functions compute:

    % -> beta
    \begin{prooftree}
        \AxiomC{$\Gamma , x : A \vdash y \Leftarrow B$}
        \AxiomC{$\Gamma \vdash t \Leftarrow A$}
        \RightLabel{($\to$-$\beta$)}
        \BinaryInfC{$\Gamma \vdash (\lambda x . y) t \equiv y[t / x] : B$}
    \end{prooftree}

    Then we introduce $\eta$-conversion which tells us if two functions applied to the same term and are judgmentally equal then the functions are judgmentally equal. This is ``function extensionality'' for judgemental equality.

    % -> eta
    \begin{prooftree}
        \AxiomC{$\Gamma , y : A \vdash M y \equiv M' y : B$}
        \RightLabel{($\to$-$\eta$)}
        \UnaryInfC{$\Gamma \vdash M \equiv M' : A \to B$}
    \end{prooftree}

    Finally we have to make sure all our rules respect judgemental equality. This means showing that $\to$ respects judgemental equality of types and that $\lambda$-terms and applications respect judgemental equality of terms.

    % -> formation congruence
    \begin{prooftree}
        \AxiomC{$\Gamma \vdash A \equiv A' \ \mathsf{type}$}
        \AxiomC{$\Gamma \vdash B \equiv B' \ \mathsf{type}$}
        \RightLabel{($\to$-$\equiv_{\mathsf{type}}$-cong)}
        \BinaryInfC{$\Gamma \vdash A \to B \equiv A' \to B' \ \mathsf{type}$}
    \end{prooftree}

    % -> introduction congruence
    \begin{prooftree}
        \AxiomC{$\Gamma , x : A \vdash M \equiv M' : B$}
        \RightLabel{($\to$-$\equiv_{\mathsf{term}}$-cong)}
        \UnaryInfC{$\Gamma \vdash \lambda x . M \equiv \lambda x . M' : A \to B$}
    \end{prooftree}

    % -> elimination congruence
    \begin{prooftree}
        \AxiomC{$\Gamma \vdash M \equiv M' : A \to B$}
        \AxiomC{$\Gamma \vdash N \equiv N' : A$}
        \RightLabel{($\to$-elim-cong)}
        \BinaryInfC{$\Gamma \vdash M N \equiv M' N' : A \to B$}
    \end{prooftree}

\end{defin}

\begin{remark}
    Notice that we don't ensure that types compute the same way. This is because the computation rules will not be used in the type checking process and are therefore irrelevant to the inversion lemmas. Later we will prove that ``fully reduced'' computations are in fact equal. This is known as the Church-Rosser theorem.
\end{remark}

We define the product type as follows.

\begin{defin}[Product type]
    
    Given two types, we have their product type:
    
    % Product formation
    \begin{prooftree}
        \AxiomC{$\Gamma \vdash A \ \mathsf{type}$}
        \AxiomC{$\Gamma \vdash B \ \mathsf{type}$}
        \RightLabel{($\times$-form)}
        \BinaryInfC{$\Gamma \vdash A \times B \ \mathsf{type}$}
    \end{prooftree}
    
    We define ordered pairs as taking a term of each type:
    
    % Product introduction
    \begin{prooftree}
        \AxiomC{$\Gamma \vdash a \Leftarrow A$}
        \AxiomC{$\Gamma \vdash b \Leftarrow B$}
        \RightLabel{($\times$-intro)}
        \BinaryInfC{$\Gamma \vdash (a, b) \Rightarrow A \times B$}
    \end{prooftree}
    
    We give two eliminators for pairs, the first and second elements:
    
    % Product eliminators
    \begin{center}
        \AxiomC{$\Gamma \vdash t \Leftarrow A \times B$}
        \RightLabel{($\times$-elim${}_1$)}
        \UnaryInfC{$\Gamma \vdash \fst(t) \Rightarrow A$}        
        \DisplayProof
        \hskip 1.5em
        \AxiomC{$\Gamma \vdash t \Leftarrow A \times B$}
        \RightLabel{($\times$-elim${}_2$)}
        \UnaryInfC{$\Gamma \vdash \snd(t) \Rightarrow B$}
        \DisplayProof
    \end{center}
    
    And we finally need to dictate how this is computed:
    
    % Product betas
    \begin{center}
        \AxiomC{$\Gamma \vdash x \Leftarrow A$}
        \AxiomC{$\Gamma \vdash y \Leftarrow B$}
        \RightLabel{($\times$-$\beta_1$)}
        \BinaryInfC{$\Gamma \vdash \fst(x,y)\equiv x : A$}
        \DisplayProof
        \hskip 1.5em
        \AxiomC{$\Gamma \vdash x \Leftarrow A$}
        \AxiomC{$\Gamma \vdash y \Leftarrow B$}
        \RightLabel{($\times$-$\beta_2$)}
        \BinaryInfC{$\Gamma \vdash \snd(x,y)\equiv y : B$}
        \DisplayProof
    \end{center}
    
    However we need to be careful since there is a nontrivial equality we must also add as a rule:
    
    % Product eta
    \begin{prooftree}
        \AxiomC{$\Gamma \vdash \fst(t) \equiv \fst(t') : A$}
        \AxiomC{$\Gamma \vdash \snd(t) \equiv \snd(t') : B$}
        \RightLabel{($\times$-$\eta$)}
        \BinaryInfC{$\Gamma \vdash t \equiv t' : A \times B$}
    \end{prooftree}

\end{defin}

\begin{remark}
    There are many other ways to present product types, the eliminators are in a sense not unique. Typically in presentations of type theory [[LIKE IN MARTIN-LOF]] an inductive principle is given. This is simply just a way to build functions out of the type, the elimination principle is stated like that. What we note is that rule is in fact admissible in the presence of our $\fst$ and $\snd$ eliminators. We also argue that the $\fst$ and $\snd$ approach more closely matches what a programmer will do with the type theory. Elimination principles in general correspond to left[[or right I need to check]] universal properties of the categorical semantic counterparts. 
\end{remark}

\begin{remark}
    Our presentation of $\eta$-reduction is unconventional. The traditional $\eta$
    \begin{prooftree}
        \AxiomC{$\Gamma \vdash t \Leftarrow A \times B$}
        \UnaryInfC{$\Gamma \vdash (\fst(t),\snd(t))\equiv t$}
    \end{prooftree}
    Is in fact admissible by observing the following proof tree:
    [[Include admissibility tree]]
    We choose our presentation because it more clearly display what $\eta$ really means and why it is there.
\end{remark}

We will also need to add a unit type. This will be the simplest type, with only one term.

\begin{defin}[Unit type]
    We begin with the formation rules, essentially saying that the unit type exists.

    % Unit formation
    \begin{prooftree}
        \AxiomC{}
        \RightLabel{($\mathbf{1}$-form)}
        \UnaryInfC{$\mathbf{1}\ \mathsf{type}$}
    \end{prooftree}

    We then say that the unit type has a term:

    % Unit introduction
    \begin{prooftree}
        \AxiomC{}
        \RightLabel{($\mathbf{1}$-intro)}
        \UnaryInfC{$\Gamma \vdash * \Rightarrow \mathbf{1}$}
    \end{prooftree}
\end{defin}

\begin{remark}
    We don't need to give any more rules since the unit type has all the properties we need. Our rules for $\to$ allow us to build constant functions anyway. And we note that all functions $\mathbf{1} \to A$ are constant functions!
\end{remark}

[[TODO: Clear up wording maybe?]]
\begin{remark}
    We make an important note that this is not the simplest presentation of the STLC of which there are many variations thereof. We chose judgemental equality and bidirectional type checking because these are features we will need if we are to enrich our type system with dependent types.
\end{remark}

\subsection{Inversion lemmas}
Having listed all these rules, we need \emph{Inversion lemmas} detailing how different judgements can \emph{only} come from a set of given judgements. This is a crucial analysis if we wish to construct a type checking algorithm. An inversion lemma for a type theory is typically very difficult to state, and extremely tedious to prove. But nonetheless is essential if we want to induct over terms. These are also known as \emph{Generation lemmas} \cite{Sorensen, harper_2016}.

Luckily we set up syntax in such a way that we only need induct over the syntax. So we pick a syntactic form and the inversion lemma will tell us exactly how we can arrive at that conclusion. Let us list all term syntax we can create in STLC. We will write them in Backus-Naur form (BNF) [CITATION] which is a common and clear way to write inductive generators:

$$
    \mathrm{Term} ::= x \mid \lambda x . a \mid (a, b) \mid a b \mid c
$$

Where $x$ is a variable, $a, b$ are terms and $c$ is a constant, in this case any of $*$, $\fst$, $\snd$. We may also list the types that we have:

$$
    \mathrm{Type} ::= A \mid A \times B \mid A \to B \mid \mathbf{1}
$$

Where $A, B$ are types.


\begin{lemma}[Inversion lemmas]\label{inversion}
    In the STLC the following judgement forms can only be derived in a specific way:
    If $\Gamma \vdash t \Leftarrow T$ then by induction on the syntax of $t$, one of the following must occur:
    \begin{enumerate}[(a)]
        \item If $t = x$, then $(x : T) \in \Gamma$.\label{inv_1_a}
        \item If $t = \lambda x . y$, then $\Gamma , x : A \vdash y : B$ and $\Gamma \vdash T \equiv A \to B \ \mathsf{type}$.\label{inv_1_b}
        \item If $t = (a , b)$, then $\Gamma \vdash a \Leftarrow A$, $\Gamma \vdash b \Leftarrow B$ and $\Gamma \vdash T \equiv A \times B \ \mathsf{type}$.\label{inv_1_c}
        \item If $t = a b$, then $\Gamma \vdash a \Leftarrow A \to T$ and $\Gamma \vdash b \Leftarrow A$ for some type $A$.\label{inv_1_d}
        \item If $t = *$, then $\Gamma \vdash T \equiv \mathbf{1}\ \mathsf{type}$.\label{inv_1_e}
        \item If $t = \fst$, then $\Gamma \vdash T \equiv A \times B \to A$ for some types $A$ and $B$.\label{inv_1_f}
        \item If $t = \snd$, then $\Gamma \vdash T \equiv A \times B \to B$ for some types $A$ and $B$.\label{inv_1_g}
    \end{enumerate}
\end{lemma}

\begin{proof}
    We argue for each case:
    \begin{enumerate}[(a)]
        \item Observe that there is only one rule, namely (switch), which has the conclusion $\Gamma \vdash x \Leftarrow T$, hence it must be the case that $\Gamma \vdash x \Rightarrow T$. Next observe that there is one rule, namely (var), whose conclusion has a variable. This leads to the necessary assumption of $(x : T) \in \Gamma$. We note that it could be the case that $(x : T') \in \Gamma$ for some other type $T'$, in which case whilst switching we need further assume that $\Gamma \vdash T \equiv T' \ \mathsf{type}$.
        
        \item As before we must (switch), whilst doing so we notice that $\Gamma \vdash \lambda x . y \Rightarrow T'$ only occurs in the conclusion of ($\to$-intro) which tells us that $T' = A \to B$ for some types $A$ and $B$. Thus whilst switching we must also assume $\Gamma \vdash T \equiv A \to B \ \mathsf{type}$. And of course, we must assume the hypothesis of ($\to$-intro) which is $\Gamma , x : A \vdash y \Leftarrow B$.
        
        \item Similarly $(a, b)$ only occurs in ($\times$-intro) hence we must switch with the hypothesis that $\Gamma \vdash T \equiv A \times B$ for some types $A$ and $B$. Then the hypothesis of ($\times$-intro) says it must be the case that both $\Gamma \vdash a \Leftarrow A$ and $\Gamma \vdash b \Leftarrow B$ hold.
        
        \item To derive $\Gamma \vdash a b \Leftarrow T$ we switch with reflexivity (cswitch) to get $\Gamma \vdash a b \Rightarrow T$ and noticing that applications appear only in ($\to$-elim), ($\times$-elim${}_1$) or ($\times$-elim${}_2$). For the first notice that we would need to assume the existence of a type $A$ such that $\Gamma \vdash a \Leftarrow A \to T$ and $\Gamma \vdash b \Leftarrow A$. For the later two, notice that the same occurs but for some type $A \times T$ or $T \times A$ for some type $A$ instead.
        
        \item The only way to derive $\Gamma \vdash * \Leftarrow T$ is by (switch) under the assumption that $\Gamma \vdash T \equiv \mathbf{1} \ \mathsf{type}$. This can be observed since ($\mathbf{1}$-intro) is the only rule to mention $*$ in the conclusion.
        
        \item Consider the rule ($\times$-elim${}_1$), notice if we start by assuming the conclusion $\Gamma \vdash \fst (t) \Rightarrow A$ we could also derive it through ($\to$-elim), leading to $\Gamma \fst \Leftarrow A \times B \to A$ and $\Gamma \vdash t \Leftarrow A \times B$. For this to be consistent with ($\times$-elim${}_1$) we see that it must always therefore be the case that $\Gamma \fst \Leftarrow A \times B \to A$ for some $A$ and $B$.
        \item Same argument as before but adapted to $\snd$. 
    \end{enumerate}
\end{proof}

\begin{remark}
    Note that we only considered \emph{inadmissible} rules.
\end{remark}

\subsection{Type checking}

There are several natural problems that occur in a typed system:

Firstly there are the problems of checking whether a given judgement is true:

\begin{defin}
    Type checking is the problem of determining the truth of a statement $\Gamma \vdash a \Leftarrow A$.
\end{defin}

\begin{remark}
    We do not consider $\Gamma \vdash a \Leftarrow A$ since this will always be given by a (switch).
\end{remark}

We would ideally wish for there to be an algorithm that will determine the truth of such a statement. Such an algorithm would render the problem of type checking in the STLC \emph{decidable}.

\begin{theorem}
    There is an algorithm that can decide the truth of the statement $\Gamma \vdash a \Leftarrow A$ in STLC.
\end{theorem}

\begin{proof}
    We will not prove the full statement since this will require us to induct over syntax. We instead note some observations and sketch how such an algorithm may function. For demonstrations see Examples \ref{swap}, \ref{curry}, \ref{uncurry}.
    We notice that the inversion lemmas \ref{inversion} give us strong conditions on what a derivation tree ought to look like. In fact if we can contradict the inversion lemmas we will be able to decide that $\Gamma \vdash a \Leftarrow A$ is false.
    The only typing hypotheses we would have are those that arise form elimination rules such as ($\to$-elim), ($\times$-elim${}_1$) and ($\times$-elim${}_2$). Everything else is exactly how the inversion lemmas state. If the inversion lemma says that $\Gamma \vdash T \equiv A \times B$ then this would need to hold by reflexivity.
\end{proof}


\begin{comment}
%\subsection{Lambda calculus}
%We recall that there are 3 kinds of expressions in lambda calculus: variables, abstractions and applications. These are defined inductively on themselves. A variable is simply a string of characters from an alphabet. A lambda abstraction looks like $\lambda x.y$ where $x$ is some variable and $y$ is some expression. There are alternate ways of writing this, allowing us to drop the need for naming $x$, for example de Brujin indices. Finally an application is simply the concatenation $ab$ of two expressions $a$ and $b$. We will assume that  This fully describes the syntax of this type theory. We will now introduce some rules that tell us which expressions we can derive from other expressions. Firstly we have $\beta$-reduction which tells us if we have an expression of the form $(\lambda x . y)z$ this can be reduced to an expression where all occurrences of $x$ in $y$ are replaced with the expression $z$. We also have $\alpha$-conversion which I would argue isn't really a rule as naming of variables can be completely avoided in the first place using de Brujin indices or even combinators. \cite{BarendregtHenk2013Lcwt, hottbook}

%\subsection{Contexts}
%In mathematics we work with contexts implicitly. That is there is always an ambient knowledge of what has been defined. Mostly due to the nature of how we read mathematical papers. We can make this explicit using contexts. We will not however, use contexts in our discussion of type theory but we will provide a formal exposition in the appendix.

\subsection{Judgements}
Our judgements:
\begin{center}
    \begin{tabular}{c | c}
        $\Gamma\ \mathrm{ctx}$ &  $\Gamma$ is a well-formed context. \\
        $\Gamma \vdash A\ \mathrm{Type}$ & $A$ is a type in context $\Gamma$. \\
        $\Gamma \vdash x : A$ & $x$ is a term of type $A$ in context $\Gamma$. \\
%        $\Gamma \vdash x \equiv y : A$ & the terms $x$ and $y$ of type $A$ are definitionally equal in context $\Gamma$
    \end{tabular}
\end{center}


Type theory ``will be about'' deriving judgements from other judgements. Which can be concisely summarised in the form of an inference rule

$$\frac{A_1\quad A_2 \quad \cdots \quad A_n}{B}$$

which says that given the judgements $A_1,\dots,A_n$ we can derive the judgement $B$.

\subsection{Structural rules}
We now look at the rules that govern contexts and the structure of our type system.

We begin with a rule stating that the empty context (which as contexts are sets or lists is well-defined) is well-formed. Which is another way of stating that the context was grown in a specified way and is not just an arbitrary list or set of variables.

\begin{prooftree}
    \AxiomC{}
    \RightLabel{empty-ctx}
    \UnaryInfC{$\varnothing$ ctx}
    \singleLine
\end{prooftree}

We also want the concatenation of two well-formed contexts to be well-formed.

\begin{prooftree}
    \AxiomC{$\Gamma$ ctx}
    \AxiomC{$\Delta$ ctx}
    \BinaryInfC{$\Gamma,\Delta$ ctx}
\end{prooftree}

We omit rules about repeating or removing repeated elements and ordering lists (think of them as finite sets).

A variable is a statement of the form $x : A$ where $x$ is known as the term and $A$ its type.

\subsection{Function types}

We introduce a formation rule for the function type.

\begin{prooftree}
    \RightLabel{$(\to)$-form}
    \AxiomC{$\Gamma \vdash A\ \mathrm{Type}$}
    \AxiomC{$\Gamma \vdash B\ \mathrm{Type}$}
    \BinaryInfC{$\Gamma \vdash A \to B\ \mathrm{Type}$}
\end{prooftree}

We now need a rule for producing terms of this new type. We introduce the introduction rule for the function type.

\begin{prooftree}
    \RightLabel{$(\to)$-intro}
    \AxiomC{$\Gamma, x : A \vdash y : B$}
    \UnaryInfC{$\Gamma \vdash (\lambda x . y) : A \to B$}
\end{prooftree}

We will sometimes call this lambda abstraction. We next introduce a way to apply these functions to terms in their domains. We introduce our elimination rule for the function type.

\begin{prooftree}
    \RightLabel{$(\to)$-elim}
    \AxiomC{$\Gamma \vdash f : A \to B$}
    \AxiomC{$\Gamma \vdash a : A$}
    \BinaryInfC{$\Gamma \vdash f(a) : B$}
\end{prooftree}

This is essentially useless unless we have a way to compute (or reduce) this expression. This is where our computation rule comes in. The computation rule will tell us how our elimination rule and introduction rule interact.
\begin{prooftree}
    \RightLabel{$(\to)$-comp}
    \AxiomC{$(\lambda x . y) : A \to B$}
    \AxiomC{$\Gamma, a : A \vdash (\lambda x.y)a : B$}
    \AxiomC{$\Gamma, x : A, y : B, (\lambda x . y) : A \to B, a : A \vdash (\lambda x . y) (a) : B$}
    \UnaryInfC{$\Gamma \vdash y[x / a] : B$}
\end{prooftree}

%%%%%%%%%%%%%%%%%%%%

We will describe what is known as a simply typed lambda calculus. There is a lot of literature on type theory, and it doesn't seem that there are many authors in agreement of ways to present it.

In \cite{BarendregtHenk2013Lcwt} a more type theoretic approach, analysing the type theory mostly in the syntactic world. This gives us a good starting point for how we want our type theory to be presented however it may not be so easy to keep an eye on how the categorical semantics (the ways we model types in mathematics) behave. In order to do this we will use references such as \cite{CroleRoyL1993Cft, JacobsCLTT, LambekJ1986Itho}. This will be from the more categorical logic school of thought, which will study type theory that is "generated" by certain categories in interest.

We start by describing a general class of simple type theories as outlined in \cite{JacobsCLTT}. Firstly we introduce the notion of a {\it signature}. Similar accounts can be found in \cite{CroleRoyL1993Cft}. This will essentially consist of "generating" a category from some signature (which can be thought of as a stripped down type theory syntax), and then studying the functors from that category into other categories. This allows nice properties from the second category to be "pulled back" onto our type theory giving it features we desire.

\begin{defin}
    A {\bf signature} is a pair $(\Typ, \mathcal{F})$ where $\Typ$ is a finite set of {\bf basic} (or {\bf atomic}) {\bf types}. And a functor $\mathcal{F} : \Typ^\star \times \Typ \to \Set$. Where $\Typ^\star$ is the Kleene-Star operation on a set (or the free monoid over $\Typ$), defined as $X^\star := \bigcup_{n\in \N} X^n$ whose elements are finite tuples of elements of $X$ for a set $X$. We have $\mathbf{Set}$ for the category of finite sets. Note that the sets in the domain of the functor are realised as discrete categories.
\end{defin}

We will usually write a signature as $\Sigma := (\Typ, \mathcal{F})$, denote $|\Sigma|:=\Typ$ and write $F: \sigma_1,\dots,\sigma_n\to\sigma_{n+1}$ when $F \in \mathcal{F}(( \sigma_1,\dots,\sigma_n ), \sigma_{n+1})$.

\begin{defin}
    Let $\Var$ be a countable set. Elements $x\in \Var$ are called {\bf variables}.
\end{defin}

Note this style of variables is essentially de Brujin indices. But allows us to have a set of names for our variables, which allows future annoyances like $\alpha$-equivalence to be sorted out easily due to the plentiful existence of bijections from $\Var \to \Var$.

\begin{defin}
    A {\bf variable declaration} is a pair $(x, \sigma) \in \Var \times \Typ$ usually written as $x : \sigma$. This can be read as "the variable $x$ has type $\sigma$. We will define $\Dec:=\Var \times \Typ$.
\end{defin}

\begin{defin}
    A {\bf context} $\Gamma$ is an element of $\Con:=\Dec^\star$. In other words, a context is a finite list of variable declarations. We will usually write a context $\Gamma$ as $v_1 : \sigma_1, \dots ,v_n : \sigma_n$. Note that the Kleene-Star has a monoid structure with operation $","$. We can thus give $\Con$ a monoid structure and write, for contexts $\Gamma$ and $\Delta$ another context $\Gamma,\Delta$ which is the concatenation of two contexts. The notation here allows the "expanded version" to coincide, as in $\Gamma,\Delta$ can be written as $v_1 : \sigma_1, \dots ,v_n : \sigma_n, w_1 : \tau_1, \dots, w_m, \tau_m$.
\end{defin}

We also note that there is a canonical inclusion $\Dec \hookrightarrow \Con$ given that $\Dec$ freely generates the monoid $\Con$. This will allow us to write $\Gamma, x:\tau$ for $v_1 : \sigma_1, \dots ,v_n : \sigma_n, x:\tau$.

We now denote the basic statements of our language. These statements are called {\bf judgements} and we will derive

%%%%%%%%%%%%%%%%%%%%
\end{comment}







