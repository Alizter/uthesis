\newcommand{\tm}{\mathrm{tm}}
\newcommand{\ty}{\mathrm{ty}}
\newcommand{\fst}{\mathrm{fst}}
\newcommand{\snd}{\mathrm{snd}}

%
% Simply typed lambda calculus
%
\section{Simply typed lambda calculus} 


First develop the features needed. Discuss the arbitrary nature of such features, then use Curry-Howard as motivation for ``the language that ought to be''. Develop STLC, discuss in detail the implications, give categorical semantics. Discuss breifly the dynamics of simply typed lambda calculus. A big disadvantage of STLC over the untyped version (which we ought to discuss since we have the tools to) is that there is no recursion. There are many ways to fix this, see G\"odel for example. In order to fix this we will introduce dependent types.

We begin by discussing the syntax of our type theory. We will start by specifying the sorts $\mathcal{S}$ of our type theory.

\begin{defin}
    The sorts of simply typed lambda calculus are terms and types $\mathcal{S} := \{ \tm , \ty\}$.
\end{defin}

We now specify the operators (with generalized arities) that we defined in definition \ref{owga}. In remark \ref{opdata} we discussed the data needed to give an operator, therefore we will present all our operators in the following table.

\begin{defin}
    The operators in the syntax of simply typed lambda calculus are given by the following table:
    \begin{center}
        \begin{tabular}{ c|c|c|c|c|c|c }
        Op & Sort & Vars & Type args & Term args & Scoping & Syntax \\
        \hline
        $\to$           & \ty &  --- & $A,B$ &  ---  &  ---  & $A \to B$            \\
        $\times$        & \ty &  --- & $A,B$ &  ---  &  ---  & $A \times B$         \\
        $(-,-)$         & \tm &  --- &  ---  & $x,y$ &  ---  & $(x,y)$              \\
        $\lambda$       & \tm &  $x$ & $A,B$ &  ---  &  $M$  & $\lambda (x : A).M$  \\
        $\mathrm{App}$  & \tm &  --- & $A,B$ &  ---  & $M,N$ & $M N$
        \end{tabular}
    \end{center}
\end{defin}

\begin{remark}
    Note that some of the syntax loses information that was put in. The application is the main example of this. In practice if we know the type of $M$ and $N$ we can deduce the type of $M N$ just from the rules we will define later. The syntax is sugared or \emph{syntactic sugar} so we do not have to write so much. If done incorrectly it could be considered an abuse of notation. It should be possible to \emph{desugar} the syntax by adding an \emph{annotated} version of an operator. For example for application instead of $M N$ we could write $\mathrm{App}_{A,B}}(M;N)$. Having this information in the syntax will be useful when we want to induct over syntax, for example when proving an intiality theorem. But in practice we will save ourselves from having to write it out.
\end{remark}

\begin{defin}
    We can now construct our raw terms and types as the collection of abts (see definition \ref{abt}) over the previously defined data $\mathrm{Term} := \mathcal{B}[\varnothing]_{\tm}$ and $\mathrm{Type} := \mathcal{B}[\varnothing]_{\ty}$.
\end{defin}

\begin{remark}
    Note that we have no variables. This is because if we set the definition of abt up correctly we don't need any, but terms can have subterms (subtrees of the abt) which have variables. The sets $\mathrm{Term}$ and $\mathrm{Type}$ become \emph{all} the types and terms we ought to be able to write down from scratch.
\end{remark}

We now need to define judgements about our syntax and write down the rules to write them down. [[Make a note about substitution because afik we haven't defined it properly yet]]. 

\subsection{Judgements}


[[TODO: Clean up this whole paragraph(s)]]
We begin with our basic judgements. Of which there will be 5. Our STLC will have bidirectional typechecking, in that we will distinguish between the direction of type checking. There are several advantages of this and historically the two main systems called STLC are Curry's and Church's which simply differ in the direction of type checking. By having both directions and a sort of ``mode-switching rule'' we have far greater control and ease when describing type checking properties. We will also need to have a notion of \emph{judgemental equality} since we wish to do some computation. There are variations of this theme discussed in the statics chapter that allow us to have transition systems instead but we will use an equational style since transition systems can be derived from this. This also has the advantage of STLC becomming what is known as an ``equational theory''. This will be a useful feature for when we want to derrive categorical semantics. 

A context is a list of basic judgements. Our basic judgements are $x : A$. [[No it is not fix this]]

There are 5 judgements that we have:

\begin{itemize}
    \item $\Gamma \vdash A\ \mathsf{type}$ - ``$A$ is a type in context $\Gamma$''.
    \item $\Gamma \vdash T \Leftarrow A$ - ``$T$ can be checked to have type $A$ in context $\Gamma$''.
    \item $\Gamma \vdash T \Rightarrow A$ - ``$T$ synthesises the type $A$ in context $\Gamma$''.
    \item $\Gamma \vdash A \equiv B\ \mathsf{type}$ - ``$A$ and $B$ are jdugementally equal types in context $\Gamma$''.
    \item $\Gamma \vdash S \equiv T : A$ - ``$S$ and $T$ are judgementally equal terms of type $A$ in context $\Gamma$''.
\end{itemize}

\subsection{Structural rules}

Structural rules will dictate how our judgements interact with eachother, how different contexts can be formed and how substitution works. This is all roughly what a ``type theory'' ought to provide.

\begin{defin}
    We begin with the \emph{variable} rule, this says that if a term $x$ appears with a type $A$ as an element in a context $\Gamma$ then $x$ synthesises a type $A$ in context $\Gamma$. Or written more succiently as:

    % Variable rule
    \begin{prooftree}
        \AxiomC{$(x:A) \in \Gamma$}
        \RightLabel{(var)}
        \UnaryInfC{$\Gamma \vdash x \Rightarrow A$}
    \end{prooftree}
\end{defin}

Other structural rules: weakening, contraction and substitution are all admissible. [[What does it mean for a rule to be admissible? We have defined this previously but we need to carefully state these facts, and prove them too!]]

\end{defin}
    One of the features of bidirectional type checking is that we can switch the mode we are in. This is expressed as the mode switching rule:

    % Switch rule
    \begin{prooftree}
        \AxiomC{$\Gamma \vdash t \Rightarrow A$}
        \AxiomC{$\Gamma \vdash A \equiv B \ \mathsf{type}$}
        \RightLabel{(switch)}
        \BinaryInfC{$\Gamma \vdash t \Leftarrow B$}
    \end{prooftree}
\end{defin}

\begin{remark}
    This rule has been specially set up in that it will be the \emph{only way} to derive $\Gamma \vdash T \Leftarrow B$. These are the kinds of properties we would like our syntax to have. A careful analysis will be done under the name of \emph{inversion lemma}. [[Link to inversion lemma?]]

    In a unidirectional type system, the judgements $\Gamma \vdash T \Rightarrow A$ and $\Gamma \vdash T \Leftarrow B$ are collapsed into one: $\Gamma \vdash T : A$. And now the mode-switching rule may have a more familiar form:

    \begin{prooftree}
        \AxiomC{$\Gamma \vdash t : A$}
        \AxiomC{$\Gamma \vdash A \equiv B \ \mathsf{type}$}
        \BinaryInfC{$\Gamma \vdash t : B$}
    \end{prooftree}

    Which shows that it is actually a rule about substituting along a judgemental equality! But this is a problem since a type checking algorithm will have to decide when to stop doing this. This is one of the big advantages that bidirectional type checking has over unidirectional type checking. The type checking algorithm will be simpler! [[TODO: Clean up and discuss type checking in more detail]]
\end{remark}

\begin{remark}
    Occasionally, we will simply mode-switch using reflexivity $\Gamma \vdash A \equiv A \ \mathsf{type}$, in which case we will abbreviate the rule as follows:
    % compact switch
    \begin{prooftree}
        \AxiomC{$\Gamma \vdash t \Rightarrow A$}
        \RightLabel{(switch)}
        \UnaryInfC{$\Gamma \vdash t \Leftarrow A$}
    \end{prooftree}
\end{remark}

\subsection{Equality rules}
Finally we have some structural rules for our two judgemental equality judgements. We wish for these to be an equivalence relation and that they are compatible with eachother.

First we begin with the structural rules for the judgement form $- \equiv -\ \mathsf{type}$:

\begin{defin}

    % Reflexivity of judgemental equality of types
    We wish for our judgemental equality of types to be reflexive:
    \begin{prooftree}
        \AxiomC{\Gamma \vdash A \ \mathsf{type}}
        \RightLabel{($\equiv_{\mathsf{type}}$-reflexivity)}
        \UnaryInfC{$\Gamma \vdash A \equiv A\ \mathsf{type}$}
    \end{prooftree}

    % Symmetry of judgemental equality of types
    We want our judgemental equality of types to be symmetric:
    \begin{prooftree}
        \AxiomC{$\Gamma \vdash A \equiv B \ \mathsf{type}$}
        \RightLabel{($\equiv_{\mathsf{type}}$-symmetry)}
        \UnaryInfC{$\Gamma \vdash B \equiv A \ \mathsf{type}$}
    \end{prooftree}

    and our judgemental equality of types to be transitive:

    % Transitivity of judgemental equality of types
    \begin{prooftree}
        \AxiomC{$\Gamma \vdash B \ \mathsf{type}$}
        \AxiomC{$\Gamma \vdash A \equiv B\ \mathsf{type}$}
        \AxiomC{$\Gamma \vdash B \equiv C\ \mathsf{type}$}
        \RightLabel{($\equiv_\mathsf{type}$-transitivity)}
        \TrinaryInfC{$\Gamma \vdash A \equiv C\ \mathsf{type}$}
    \end{prooftree}

    Notice how the previous rule also checks that $B$ is a type. This is because if we did not do this, we could insert any symbol in. This is clearly undesirable. It also demonstrates how subtly sensitive rules are.

    Now we list the rules making the judgement form $- \equiv - : A$ into an equivalence relation:

    % Reflexivity of judgemental equality of terms
    We wish for our judgemental equality of terms to be reflexive:
    \begin{prooftree}
        \AxiomC{$\Gamma \vdash t \Rightarrow A$}
        \RightLabel{($\equiv_{\mathsf{term}}$-reflexivity)}
        \UnaryInfC{$\Gamma \vdash t \equiv t : A$}
    \end{prooftree}

    % Symmetry of judgemental equality of terms
    We want our judgemental equality of terms to be symmetric:
    \begin{prooftree}
        \AxiomC{$\Gamma \vdash s \equiv t : A$}
        \RightLabel{($\equiv_{\mathsf{term}}$-symmetry)}
        \UnaryInfC{$\Gamma \vdash t \equiv s : A$}
    \end{prooftree}

    % Transitivity of judgemental equality of terms
    and our judgemental equality of terms to be transitive:
    \begin{prooftree}
        \AxiomC{$\Gamma \vdash t \Leftarrow A $}
        \AxiomC{$\Gamma \vdash s \equiv t : A$}
        \AxiomC{$\Gamma \vdash t \equiv r : A$}
        \RightLabel{($\equiv_{\mathsf{term}}$-transitivity)}
        \TrinaryInfC{$\Gamma \vdash s \equiv r : A$}
    \end{prooftree}

    as we stated before for transitivity judgemental equality of types we need to also check that the middle term $T$ is actually a term.

    % judgemental equality of types - judgemental equality of terms - congruence
    Finally we need a rule that will make  that judgemental equality of types and judgemental equality of terms interact the way we expect them to:
    \begin{prooftree}
        \AxiomC{$\Gamma \vdash A \ \mathsf{type}$}
        \AxiomC{$\Gamma \vdash s \equiv t : A$}
        \AxiomC{$\Gamma \vdash A \equiv B\ \mathsf{type}$}
        \RightLabel{($\equiv_{\mathsf{term}}$-$\equiv_{\mathsf{type}}$-compat)}
        \TrinaryInfC{$\Gamma \vdash s \equiv t : B$}
    \end{prooftree}
\end{defin}

\subsection{Type formers}
What we have constructed thusfar is essentially an ``empty type theory''. What we have included which other authors typcially gloss over is a clean way of constructing a typechecking algorithm: bidirectional typechecking and an account of judgemental equality. We now study what are known as type formers, typically when we wish to add a new type to a type theory we need to think about a collection of rules. These can roughly be sorted into 5 kinds of rules:

\begin{itemize}
    \item Formation rules - How can I construct my type?
    \item Introduction rules - Which terms synthesise this type?
    \item Elimination rules - How can terms of this type be used?
    \item Computation (or equality) rules - How do terms of this type compute? (Normalise, etc.)
    \item Congruence rules - How do all the previous rules interact with judgemental equality
\end{itemize}

We make a note that although we will be providing all the rules, the congruence rules can be typically derrived from the others. Although we do not know exactly how to do this so we will provide them explicitly. We also note that not every type need computation rules.

Building on top of our ``empty type theory'' we introduce $\to$ the function type former:

\begin{defin}

    Our formation rules tell us how to construct arrow types from other types:
    
    % -> formation
    \begin{prooftree}
        \AxiomC{$\Gamma \vdash A\ \mathsf{type}$}
        \AxiomC{$\Gamma \vdash B\ \mathsf{type}$}
        \RightLabel{($\to$-form)}
        \BinaryInfC{$\Gamma \vdash A \to B \ \mathsf{type}$}
    \end{prooftree}

    Our introduction rule tells us how to construct terms of our type. This is also known as $\lambda$-abstraction:

    % -> introduction
    \begin{prooftree}
        \AxiomC{$\Gamma , x : A\vdash M \Leftarrow B$}
        \RightLabel{($\to$-intro)}
        \UnaryInfC{$\Gamma \vdash \lambda x . M \Rightarrow A \to B$}
    \end{prooftree}

    Our elimination rule tells us how to use terms of this type. For function types this corresponds to application:

    % -> elimination
    \begin{prooftree}
        \AxiomC{$\Gamma \vdash M \Leftarrow A \to B$}
        \AxiomC{$\Gamma \vdash N \Leftarrow A$}
        \RightLabel{($\to$-elim)}
        \BinaryInfC{$\Gamma \vdash M N \Rightarrow B$}
    \end{prooftree}

    And finally we have computation rules which tell us how to compute our terms. We will later prove results about normalisation of the lambda calculus. We start with $\beta$-reduction which tells us how applicated functions compute:

    % -> beta
    \begin{prooftree}
        \AxiomC{$\Gamma , x : A \vdash y \Leftarrow B$}
        \AxiomC{$\Gamma \vdash t \Leftarrow A$}
        \RightLabel{($\to$-$\beta$)}
        \BinaryInfC{$\Gamma \vdash (\lambda x . y) t \equiv y[t / x] : B$}
    \end{prooftree}

    Then we introduce $\eta$-conversion which tells us if two functions applied to the same term and are judgementally equal then the functions are judgementally equal. This is ``function extensionality'' for judgemental equality.

    % -> eta
    \begin{prooftree}
        \AxiomC{$\Gamma , y : A \vdash M y \equiv M' y : B$}
        \RightLabel{($\to$-$\eta$)}
        \UnaryInfC{$\Gamma \vdash M \equiv M' : A \to B$}
    \end{prooftree}

    Finally we have to make sure all our rules respect judgemental equality. This means showing that $\to$ respects judgemental equality of types and that $\lambda$-terms and applications respect judgemental equality of terms.

    % -> formation congruence
    \begin{prooftree}
        \AxiomC{$\Gamma \vdash A \equiv A' \ \mathsf{type}$}
        \AxiomC{$\Gamma \vdash B \equiv B' \ \mathsf{type}$}
        \RightLabel{($\to$-$\equiv_{\mathsf{type}}$-cong)}
        \BinaryInfC{$\Gamma \vdash A \to B \equiv A' \to B' \ \mathsf{type}$}
    \end{prooftree}

    % -> introduction congruence
    \begin{prooftree}
        \AxiomC{$\Gamma , x : A \vdash M \equiv M' : B$}
        \RightLabel{($\to$-$\equiv_{\mathsf{term}}$-cong)}
        \UnaryInfC{$\Gamma \vdash \lambda x . M \equiv \lambda x . M' : A \to B$}
    \end{prooftree}

    % -> elimination congruence
    \begin{prooftree}
        \AxiomC{$\Gamma \vdash M \equiv M' : A \to B$}
        \AxiomC{$\Gamma \vdash N \equiv N' : A$}
        \RightLabel{($\to$-elim-cong)}
        \BinaryInfC{$\Gamma \vdash M N \equiv M' N' : A \to B$}
    \end{prooftree}

\end{defin}

\begin{remark}
    Notice that we don't ensure that types compute the same way. This is because the computation rules will not be used in the type checking process and are therefore irrelevant to the inversion lemmas. Later we will prove that ``fully reduced'' computations are in fact equal. This is known as the Church-Rosser theorem.
\end{remark}

We define the product type as follows.

\begin{defin}[Product type]
    
    Given two types, we have their product type:
    
    % Product formation
    \begin{prooftree}
        \AxiomC{$\Gamma \vdash A \ \mathsf{type}$}
        \AxiomC{$\Gamma \vdash B \ \mathsf{type}$}
        \RightLabel{($\times$-form)}
        \BinaryInfC{$\Gamma \vdash A \times B \ \mathsf{type}$}
    \end{prooftree}
    
    We define ordered pairs as taking a term of each type:
    
    % Product introduction
    \begin{prooftree}
        \AxiomC{$\Gamma \vdash a \Leftarrow A$}
        \AxiomC{$\Gamma \vdash b \Leftarrow B$}
        \RightLabel{($\times$-intro)}
        \BinaryInfC{$\Gamma \vdash (a, b) \Rightarrow A \times B$}
    \end{prooftree}
    
    We give two eliminators for pairs, the first and second elements:
    
    % Product eliminators
    \begin{center}
        \AxiomC{$\Gamma \vdash t \Leftarrow A \times B$}
        \RightLabel{($\times$-elim${}_1$)}
        \UnaryInfC{$\Gamma \vdash \fst(t) \Rightarrow A$}        
        \DisplayProof
        \hskip 1.5em
        \AxiomC{$\Gamma \vdash t \Leftarrow A \times B$}
        \RightLabel{($\times$-elim${}_2$)}
        \UnaryInfC{$\Gamma \vdash \snd(t) \Rightarrow B$}
        \DisplayProof
    \end{center}
    
    And we finally need to dictate how this is computed:
    
    \begin{center}
        \AxiomC{$\Gamma \vdash x \Leftarrow A$}
        \AxiomC{$\Gamma \vdash y \Leftarrow B$}
        \RightLabel{($\times$-$\beta_1$)}
        \BinaryInfC{$\Gamma \vdash \fst(x,y)\equiv x : A$}
        \DisplayProof
        \hskip 1.5em
        \AxiomC{$\Gamma \vdash x \Leftarrow A$}
        \AxiomC{$\Gamma \vdash y \Leftarrow B$}
        \RightLabel{($\times$-$\beta_2$)}
        \BinaryInfC{$\Gamma \vdash \snd(x,y)\equiv y : B$}
        \DisplayProof
    \end{center}
    
    However we need to be careful since there is a nontrivial equality we must also add as a rule:
    
    \begin{prooftree}
        \AxiomC{$\Gamma \vdash t \Rightarrow A \times B$}
        \RightLabel{($\times$-$\eta$)}
        \UnaryInfC{$\Gamma \vdash (\fst(t),\snd(t))\equiv t : A \times B$}
    \end{prooftree}
    
\end{defin}

We will also need to add a unit type. This will be the simplest type, with only one term.

\begin{defin}[Unit type]
    We begin with the formation rules, essentially saying that the unit type exists.

    % Unit formation
    \begin{prooftree}
        \AxiomC{}
        \RightLabel{($\mathbf{1}$-form)}
        \UnaryInfC{$\mathbf{1}\ \mathsf{type}$}
    \end{prooftree}

    We then say that the unit type has a term:

    % Unit introduction
    \begin{prooftree}
        \AxiomC{}
        \RightLabel{($\mathbf{1}$-intro)}
        \UnaryInfC{$\Gamma \vdash * \Rightarrow \mathbf{1}$}
    \end{prooftree}
\end{defin}

\begin{remark}
    We don't need to give any more rules since the unit type has all the properties we need. Our rules for $\to$ allow us to build constant functions anyway. And we note that all functions $\mathbf{1} \to A$ are constant functions!
\end{remark}

[[TODO: Clear up wording maybe?]]
\begin{remark}
    We make an important note that this is not the simplest presentation of the STLC of which there are many variations thereof. We chose judgemental equality and bidirectional type checking because these are features we will need if we are to enrich our type system with dependent types.
\end{remark}

\subsection{Inversion lemmas}
Having listed all these rules we need some lemmas detailing how different terms can \emph{only} come from a set of specified rules. This is a crucial analysis if we wish to construct a type checking algorithm. An inversion lemma for a type theory is typically very difficult to state, and extremely tedious to prove. But nontheless is essential if we want to induct over terms.

Luckily we set up syntax in such a way that we only need induct over the syntax. So we pick a syntactic form and the inversion lemma will tell us exactly how we can arrive at that conclusion. Let us list all term syntax we can create in STLC:

\begin{itemize}
    \item $x$ where $x$ is a variable.
    \item $\lambda x . M$ where $M$ is a term.
    \item $(x, y)$ where $x$ and $y$ are terms.
    \item $\fst, \snd$ the eliminators of $\times$
    \item $*$ the element of $\mathbf{1}$
    \item $\mathrm{ind}_{\mathbf{1}}$ the inductor of $\mathbf{1}$
\end{itemize}

%Probably not true if we set things up correctly
%We note that these inversion lemmas will only be applicable to judgement forms such as $\Gamma \vdash x \Rightarrow A$ and $\Gamma \vdash x \Leftrightarrow A$ as judgemental equality will be far too complicated (and perhaps even impossible) to decidably derive. In times where our judgemental equality 

\begin{lemma}
    
\end{lemma}

[[TODO: State this beast]]
\begin{lemma}
    In the STLC the following term forms are generated by certain rules...
\end{lemma}

\subsection{Normalisation and Canonicity}

[[These two concepts are very related, we should find some way to talk about it, including Church-Rosser]]


\begin{comment}
%\subsection{Lambda calculus}
%We recall that there are 3 kinds of expressions in lambda calculus: variables, abstractions and applications. These are defined inductively on themselves. A variable is simply a string of characters from an alphabet. A lambda abstraction looks like $\lambda x.y$ where $x$ is some variable and $y$ is some expression. There are alternate ways of writing this, allowing us to drop the need for naming $x$, for example de Brujin indices. Finally an application is simply the concatenation $ab$ of two expressions $a$ and $b$. We will assume that  This fully describes the syntax of this type theory. We will now introduce some rules that tell us which expressions we can derive from other expressions. Firstly we have $\beta$-reduction which tells us if we have an expression of the form $(\lambda x . y)z$ this can be reduced to an expression where all occurrences of $x$ in $y$ are replaced with the expression $z$. We also have $\alpha$-conversion which I would argue isn't really a rule as naming of variables can be completely avoided in the first place using de Brujin indices or even combinators. \cite{BarendregtHenk2013Lcwt, hottbook}

%\subsection{Contexts}
%In mathematics we work with contexts implicitly. That is there is always an ambient knowledge of what has been defined. Mostly due to the nature of how we read mathematical papers. We can make this explicit using contexts. We will not however, use contexts in our discussion of type theory but we will provide a formal exposition in the appendix.

\subsection{Judgements}
Our judgements:
\begin{center}
    \begin{tabular}{c | c}
        $\Gamma\ \mathrm{ctx}$ &  $\Gamma$ is a well-formed context. \\
        $\Gamma \vdash A\ \mathrm{Type}$ & $A$ is a type in context $\Gamma$. \\
        $\Gamma \vdash x : A$ & $x$ is a term of type $A$ in context $\Gamma$. \\
%        $\Gamma \vdash x \equiv y : A$ & the terms $x$ and $y$ of type $A$ are definitionally equal in context $\Gamma$
    \end{tabular}
\end{center}


Type theory ``will be about'' deriving judgements from other judgements. Which can be concisely summarised in the form of an inference rule

$$\frac{A_1\quad A_2 \quad \cdots \quad A_n}{B}$$

which says that given the judgements $A_1,\dots,A_n$ we can derive the judgement $B$.

\subsection{Structural rules}
We now look at the rules that govern contexts and the structure of our type system.

We begin with a rule stating that the empty context (which as contexts are sets or lists is well-defined) is well-formed. Which is another way of stating that the context was grown in a specified way and is not just an arbitrary list or set of variables.

\begin{prooftree}
    \AxiomC{}
    \RightLabel{empty-ctx}
    \UnaryInfC{$\varnothing$ ctx}
    \singleLine
\end{prooftree}

We also want the concatenation of two well-formed contexts to be well-formed.

\begin{prooftree}
    \AxiomC{$\Gamma$ ctx}
    \AxiomC{$\Delta$ ctx}
    \BinaryInfC{$\Gamma,\Delta$ ctx}
\end{prooftree}

We omit rules about repeating or removing repeated elements and ordering lists (think of them as finite sets).

A variable is a statement of the form $x : A$ where $x$ is known as the term and $A$ its type.

\subsection{Function types}

We introduce a formation rule for the function type.

\begin{prooftree}
    \RightLabel{$(\to)$-form}
    \AxiomC{$\Gamma \vdash A\ \mathrm{Type}$}
    \AxiomC{$\Gamma \vdash B\ \mathrm{Type}$}
    \BinaryInfC{$\Gamma \vdash A \to B\ \mathrm{Type}$}
\end{prooftree}

We now need a rule for producing terms of this new type. We introduce the introduction rule for the function type.

\begin{prooftree}
    \RightLabel{$(\to)$-intro}
    \AxiomC{$\Gamma, x : A \vdash y : B$}
    \UnaryInfC{$\Gamma \vdash (\lambda x . y) : A \to B$}
\end{prooftree}

We will sometimes call this lambda abstraction. We next introduce a way to apply these functions to terms in their domains. We introduce our elimination rule for the function type.

\begin{prooftree}
    \RightLabel{$(\to)$-elim}
    \AxiomC{$\Gamma \vdash f : A \to B$}
    \AxiomC{$\Gamma \vdash a : A$}
    \BinaryInfC{$\Gamma \vdash f(a) : B$}
\end{prooftree}

This is essentially useless unless we have a way to compute (or reduce) this expression. This is where our computation rule comes in. The computation rule will tell us how our elimination rule and introduction rule interact.
\begin{prooftree}
    \RightLabel{$(\to)$-comp}
    \AxiomC{$(\lambda x . y) : A \to B$}
    \AxiomC{$\Gamma, a : A \vdash (\lambda x.y)a : B$}
    \AxiomC{$\Gamma, x : A, y : B, (\lambda x . y) : A \to B, a : A \vdash (\lambda x . y) (a) : B$}
    \UnaryInfC{$\Gamma \vdash y[x / a] : B$}
\end{prooftree}

%%%%%%%%%%%%%%%%%%%%

We will describe what is known as a simply typed lambda calculus. There is a lot of literature on type theory, and it doesn't seem that there are many authors in agreement of ways to present it.

In \cite{BarendregtHenk2013Lcwt} a more type theoretic approach, analysing the type theory mostly in the syntactic world. This gives us a good starting point for how we want our type theory to be presented however it may not be so easy to keep an eye on how the categorical semantics (the ways we model types in mathematics) behave. In order to do this we will use references such as \cite{CroleRoyL1993Cft, JacobsCLTT, LambekJ1986Itho}. This will be from the more categorical logic school of thought, which will study type theory that is "generated" by certain categories in interest.

We start by describing a general class of simple type theories as outlined in \cite{JacobsCLTT}. Firstly we introduce the notion of a {\it signature}. Similar accounts can be found in \cite{CroleRoyL1993Cft}. This will essentially consist of "generating" a category from some signature (which can be thought of as a stripped down type theory syntax), and then studying the functors from that category into other categories. This allows nice properties from the second category to be "pulled back" onto our type theory giving it features we desire.

\begin{defin}
	A {\bf signature} is a pair $(\Typ, \mathcal{F})$ where $\Typ$ is a finite set of {\bf basic} (or {\bf atomic}) {\bf types}. And a functor $\mathcal{F} : \Typ^\star \times \Typ \to \Set$. Where $\Typ^\star$ is the Kleene-Star operation on a set (or the free monoid over $\Typ$), defined as $X^\star := \bigcup_{n\in \N} X^n$ whose elements are finite tuples of elements of $X$ for a set $X$. We have $\mathbf{Set}$ for the category of finite sets. Note that the sets in the domain of the functor are realised as discrete categories.
\end{defin}

We will usually write a signature as $\Sigma := (\Typ, \mathcal{F})$, denote $|\Sigma|:=\Typ$ and write $F: \sigma_1,\dots,\sigma_n\to\sigma_{n+1}$ when $F \in \mathcal{F}(( \sigma_1,\dots,\sigma_n ), \sigma_{n+1})$.

\begin{defin}
    Let $\Var$ be a countable set. Elements $x\in \Var$ are called {\bf variables}.
\end{defin}

Note this style of variables is essentially de Brujin indices. But allows us to have a set of names for our variables, which allows future annoyances like $\alpha$-equivalence to be sorted out easily due to the plentiful existence of bijections from $\Var \to \Var$.

\begin{defin}
	A {\bf variable declaration} is a pair $(x, \sigma) \in \Var \times \Typ$ usually written as $x : \sigma$. This can be read as "the variable $x$ has type $\sigma$. We will define $\Dec:=\Var \times \Typ$.
\end{defin}

\begin{defin}
    A {\bf context} $\Gamma$ is an element of $\Con:=\Dec^\star$. In other words, a context is a finite list of variable declarations. We will usually write a context $\Gamma$ as $v_1 : \sigma_1, \dots ,v_n : \sigma_n$. Note that the Kleene-Star has a monoid structure with operation $","$. We can thus give $\Con$ a monoid structure and write, for contexts $\Gamma$ and $\Delta$ another context $\Gamma,\Delta$ which is the concatenation of two contexts. The notation here allows the "expanded version" to coincide, as in $\Gamma,\Delta$ can be written as $v_1 : \sigma_1, \dots ,v_n : \sigma_n, w_1 : \tau_1, \dots, w_m, \tau_m$.
\end{defin}

We also note that there is a canonical inclusion $\Dec \hookrightarrow \Con$ given that $\Dec$ freely generates the monoid $\Con$. This will allow us to write $\Gamma, x:\tau$ for $v_1 : \sigma_1, \dots ,v_n : \sigma_n, x:\tau$.

We now denote the basic statements of our language. These statements are called {\bf judgements} and we will derive

%%%%%%%%%%%%%%%%%%%%
\end{comment}







