%
% Simply typed lambda calculus
%
\section{Simply typed lambda calculus} 


First develop the features needed. Discuss the arbitrary nature of such features, then use Curry-Howard as motivation for ``the language that ought to be''. Develop STLC, discuss in detail the implications, give categorical semantics. Discuss breifly the dynamics of simply typed lambda calculus. A big disadvantage of STLC over the untyped version (which we ought to discuss since we have the tools to) is that there is no recursion. There are many ways to fix this, see G\"odel for example. In order to fix this we will introduce dependent types.

We begin by discussing the syntax of our type theory. We have a set of types $\mathbf{T}::= $
and a set of terms $\mathbf{T}::=$

\subsection{Judgements}


[[TODO: Clean up this whole paragraph(s)]]
We begin with our basic judgements. Of which there will be 5. Our STLC will have bidirectional typechecking, in that we will distinguish between the direction of type checking. There are several advantages of this and historically the two main systems called STLC are Curry's and Church's which simply differ in the direction of type checking. By having both directions and a sort of ``mode-switching rule'' we have far greater control and ease when describing type checking properties. We will also need to have a notion of \emph{judgemental equality} since we wish to do some computation. There are variations of this theme discussed in the statics chapter that allow us to have transition systems instead but we will use an equational style since transition systems can be derived from this. This also has the advantage of STLC becomming what is known as an ``equational theory''. This will be a useful feature for when we want to derrive categorical semantics. 

A context is a list of basic judgements. Our basic judgements are $x : A$. [[No it is not fix this]]

There are 5 judgements that we have:

\begin{itemize}
    \item $\Gamma \vdash A\ \mathsf{type}$ - ``$A$ is a type in context $\Gamma$''.
    \item $\Gamma \vdash T \Leftarrow A$ - ``$T$ can be checked to have type $A$ in context $\Gamma$''.
    \item $\Gamma \vdash T \Rightarrow A$ - ``$T$ synthesises the type $A$ in context $\Gamma$''.
    \item $\Gamma \vdash A \equiv B\ \mathsf{type}$ - ``$A$ and $B$ are jdugementally equal types in context $\Gamma$''.
    \item $\Gamma \vdash S \equiv T : A$ - ``$S$ and $T$ are judgementally equal terms of type $A$ in context $\Gamma$''.
\end{itemize}

\subsection{Structural rules}

Structural rules will dictate how our judgements interact with eachother, how different contexts can be formed and how substitution works. This is all roughly what a ``type theory'' ought to provide.

We begin with the \emph{variable} rule, this says that if a term $x$ appears with a type $A$ as an element in a context $\Gamma$ then $x$ synthesises a type $A$ in context $\Gamma$. Or written more succiently as:

$$
    \frac{(x:A) \in \Gamma }{\Gamma \vdash x \Rightarrow A}
$$

Other structural rules: weakening, contraction and substitution are all admissible. [[What does it mean for a rule to be admissible? We have defined this previously but we need to carefully state these facts, and prove them too!]]

\subsection{Mode-switching}

One of the features of bidirectional type checking is that we can switch the mode we are in. This is expressed as the mode switching rule:

\begin{prooftree}
    \AxiomC{$\Gamma \vdash T \Rightarrow A$}
    \AxiomC{$\Gamma \vdash A \equiv B \ \mathsf{type}$}
    \BinaryInfC{$\Gamma \vdash T \Leftarrow B$}
\end{prooftree}

This rule has been specially set up in that it will be the \emph{only way} to derive $\Gamma \vdash T \Leftarrow B$. [[TODO: talk more about this]]

In a unidirectional type system, the judgements $\Gamma \vdash T \Rightarrow A$ and $\Gamma \vdash T \Leftarrow B$ are collapsed into one: $\Gamma \vdash T : A$. And now the mode-switching rule may have a more familiar form:

\begin{prooftree}
    \AxiomC{$\Gamma \vdash T : A$}
    \AxiomC{$\Gamma \vdash A \equiv B \ \mathsf{type}$}
    \BinaryInfC{$\Gamma \vdash T : B$}
\end{prooftree}

Which shows that it is actually a rule about substituting along a judgemental equality! But this is a problem since a type checking algorithm will have to decide when to stop doing this. This is one of the big advantages that bidirectional type checking has over unidirectional type checking. The type checking algorithm will be simpler! [[TODO: Clean up and discuss type checking in more detail]]

\subsection{Equality rules}
Finally we have some structural rules for our two judgemental equality judgements. We wish for these to be an equivalence relation and that they are compatible with eachother.

First we begin with the structural rules for the judgement form $- \equiv -\ \mathbf{type}$:

We wish for our judgemental equality of types to be reflexive:
$$
    \frac{}{\Gamma \vdash A \equiv A\ \mathbf{type}} \, (\equiv_{\mathbf{type}}\text{-refl})
$$

We wish for our judgemental equality of types to be symmetric:
$$
    \frac{}{}
$$

\begin{comment}
%\subsection{Lambda calculus}
%We recall that there are 3 kinds of expressions in lambda calculus: variables, abstractions and applications. These are defined inductively on themselves. A variable is simply a string of characters from an alphabet. A lambda abstraction looks like $\lambda x.y$ where $x$ is some variable and $y$ is some expression. There are alternate ways of writing this, allowing us to drop the need for naming $x$, for example de Brujin indices. Finally an application is simply the concatenation $ab$ of two expressions $a$ and $b$. We will assume that  This fully describes the syntax of this type theory. We will now introduce some rules that tell us which expressions we can derive from other expressions. Firstly we have $\beta$-reduction which tells us if we have an expression of the form $(\lambda x . y)z$ this can be reduced to an expression where all occurrences of $x$ in $y$ are replaced with the expression $z$. We also have $\alpha$-conversion which I would argue isn't really a rule as naming of variables can be completely avoided in the first place using de Brujin indices or even combinators. \cite{BarendregtHenk2013Lcwt, hottbook}

%\subsection{Contexts}
%In mathematics we work with contexts implicitly. That is there is always an ambient knowledge of what has been defined. Mostly due to the nature of how we read mathematical papers. We can make this explicit using contexts. We will not however, use contexts in our discussion of type theory but we will provide a formal exposition in the appendix.

\subsection{Judgements}
Our judgements:
\begin{center}
    \begin{tabular}{c | c}
        $\Gamma\ \mathrm{ctx}$ &  $\Gamma$ is a well-formed context. \\
        $\Gamma \vdash A\ \mathrm{Type}$ & $A$ is a type in context $\Gamma$. \\
        $\Gamma \vdash x : A$ & $x$ is a term of type $A$ in context $\Gamma$. \\
%        $\Gamma \vdash x \equiv y : A$ & the terms $x$ and $y$ of type $A$ are definitionally equal in context $\Gamma$
    \end{tabular}
\end{center}


Type theory ``will be about'' deriving judgements from other judgements. Which can be concisely summarised in the form of an inference rule

$$\frac{A_1\quad A_2 \quad \cdots \quad A_n}{B}$$

which says that given the judgements $A_1,\dots,A_n$ we can derive the judgement $B$.

\subsection{Structural rules}
We now look at the rules that govern contexts and the structure of our type system.

We begin with a rule stating that the empty context (which as contexts are sets or lists is well-defined) is well-formed. Which is another way of stating that the context was grown in a specified way and is not just an arbitrary list or set of variables.

\begin{prooftree}
    \AxiomC{}
    \RightLabel{empty-ctx}
    \UnaryInfC{$\varnothing$ ctx}
    \singleLine
\end{prooftree}

We also want the concatenation of two well-formed contexts to be well-formed.

\begin{prooftree}
    \AxiomC{$\Gamma$ ctx}
    \AxiomC{$\Delta$ ctx}
    \BinaryInfC{$\Gamma,\Delta$ ctx}
\end{prooftree}

We omit rules about repeating or removing repeated elements and ordering lists (think of them as finite sets).

A variable is a statement of the form $x : A$ where $x$ is known as the term and $A$ its type.

\subsection{Function types}

We introduce a formation rule for the function type.

\begin{prooftree}
    \RightLabel{$(\to)$-form}
    \AxiomC{$\Gamma \vdash A\ \mathrm{Type}$}
    \AxiomC{$\Gamma \vdash B\ \mathrm{Type}$}
    \BinaryInfC{$\Gamma \vdash A \to B\ \mathrm{Type}$}
\end{prooftree}

We now need a rule for producing terms of this new type. We introduce the introduction rule for the function type.

\begin{prooftree}
    \RightLabel{$(\to)$-intro}
    \AxiomC{$\Gamma, x : A \vdash y : B$}
    \UnaryInfC{$\Gamma \vdash (\lambda x . y) : A \to B$}
\end{prooftree}

We will sometimes call this lambda abstraction. We next introduce a way to apply these functions to terms in their domains. We introduce our elimination rule for the function type.

\begin{prooftree}
    \RightLabel{$(\to)$-elim}
    \AxiomC{$\Gamma \vdash f : A \to B$}
    \AxiomC{$\Gamma \vdash a : A$}
    \BinaryInfC{$\Gamma \vdash f(a) : B$}
\end{prooftree}

This is essentially useless unless we have a way to compute (or reduce) this expression. This is where our computation rule comes in. The computation rule will tell us how our elimination rule and introduction rule interact.
\begin{prooftree}
    \RightLabel{$(\to)$-comp}
    \AxiomC{$(\lambda x . y) : A \to B$}
    \AxiomC{$\Gamma, a : A \vdash (\lambda x.y)a : B$}
    \AxiomC{$\Gamma, x : A, y : B, (\lambda x . y) : A \to B, a : A \vdash (\lambda x . y) (a) : B$}
    \UnaryInfC{$\Gamma \vdash y[x / a] : B$}
\end{prooftree}

%%%%%%%%%%%%%%%%%%%%

We will describe what is known as a simply typed lambda calculus. There is a lot of literature on type theory, and it doesn't seem that there are many authors in agreement of ways to present it.

In \cite{BarendregtHenk2013Lcwt} a more type theoretic approach, analysing the type theory mostly in the syntactic world. This gives us a good starting point for how we want our type theory to be presented however it may not be so easy to keep an eye on how the categorical semantics (the ways we model types in mathematics) behave. In order to do this we will use references such as \cite{CroleRoyL1993Cft, JacobsCLTT, LambekJ1986Itho}. This will be from the more categorical logic school of thought, which will study type theory that is "generated" by certain categories in interest.

We start by describing a general class of simple type theories as outlined in \cite{JacobsCLTT}. Firstly we introduce the notion of a {\it signature}. Similar accounts can be found in \cite{CroleRoyL1993Cft}. This will essentially consist of "generating" a category from some signature (which can be thought of as a stripped down type theory syntax), and then studying the functors from that category into other categories. This allows nice properties from the second category to be "pulled back" onto our type theory giving it features we desire.

\begin{defin}
	A {\bf signature} is a pair $(\Typ, \mathcal{F})$ where $\Typ$ is a finite set of {\bf basic} (or {\bf atomic}) {\bf types}. And a functor $\mathcal{F} : \Typ^\star \times \Typ \to \Set$. Where $\Typ^\star$ is the Kleene-Star operation on a set (or the free monoid over $\Typ$), defined as $X^\star := \bigcup_{n\in \N} X^n$ whose elements are finite tuples of elements of $X$ for a set $X$. We have $\mathbf{Set}$ for the category of finite sets. Note that the sets in the domain of the functor are realised as discrete categories.
\end{defin}

We will usually write a signature as $\Sigma := (\Typ, \mathcal{F})$, denote $|\Sigma|:=\Typ$ and write $F: \sigma_1,\dots,\sigma_n\to\sigma_{n+1}$ when $F \in \mathcal{F}(( \sigma_1,\dots,\sigma_n ), \sigma_{n+1})$.

\begin{defin}
    Let $\Var$ be a countable set. Elements $x\in \Var$ are called {\bf variables}.
\end{defin}

Note this style of variables is essentially de Brujin indices. But allows us to have a set of names for our variables, which allows future annoyances like $\alpha$-equivalence to be sorted out easily due to the plentiful existence of bijections from $\Var \to \Var$.

\begin{defin}
	A {\bf variable declaration} is a pair $(x, \sigma) \in \Var \times \Typ$ usually written as $x : \sigma$. This can be read as "the variable $x$ has type $\sigma$. We will define $\Dec:=\Var \times \Typ$.
\end{defin}

\begin{defin}
    A {\bf context} $\Gamma$ is an element of $\Con:=\Dec^\star$. In other words, a context is a finite list of variable declarations. We will usually write a context $\Gamma$ as $v_1 : \sigma_1, \dots ,v_n : \sigma_n$. Note that the Kleene-Star has a monoid structure with operation $","$. We can thus give $\Con$ a monoid structure and write, for contexts $\Gamma$ and $\Delta$ another context $\Gamma,\Delta$ which is the concatenation of two contexts. The notation here allows the "expanded version" to coincide, as in $\Gamma,\Delta$ can be written as $v_1 : \sigma_1, \dots ,v_n : \sigma_n, w_1 : \tau_1, \dots, w_m, \tau_m$.
\end{defin}

We also note that there is a canonical inclusion $\Dec \hookrightarrow \Con$ given that $\Dec$ freely generates the monoid $\Con$. This will allow us to write $\Gamma, x:\tau$ for $v_1 : \sigma_1, \dots ,v_n : \sigma_n, x:\tau$.

We now denote the basic statements of our language. These statements are called {\bf judgements} and we will derive

%%%%%%%%%%%%%%%%%%%%
\end{comment}







