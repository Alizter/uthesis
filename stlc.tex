%
% Simply typed lambda calculus
%

\subsection{Lambda calculus}
We recall that there are 3 kinds of expressions in lambda calculus: variables, abstractions and applications. These are defined inductively on themselves. A variable is simply a string of characters from an alphabet. A lambda abstraction looks like $\lambda x.y$ where $x$ is some variable and $y$ is some expression. There are alternate ways of writing this, allowing us to drop the need for naming $x$, for example de Brujin indices. Finally an application is simply the concatenation $ab$ of two expressions $a$ and $b$. We will assume that  This fully describes the syntax of this type theory. We will now introduce some rules that tell us which expressions we can derive from other expressions. Firstly we have $\beta$-reduction which tells us if we have an expression of the form $(\lambda x . y)z$ this can be reduced to an expression where all occurrences of $x$ in $y$ are replaced with the expression $z$. We also have $\alpha$-conversion which I would argue isn't really a rule as naming of variables can be completely avoided in the first place using de Brujin indices or even combinators. \cite{BarendregtHenk2013Lcwt, hottbook}

\subsection{Contexts}
In mathematics we work with contexts implicitly. That is there is always an ambient knowledge of what has been defined. Mostly due to the nature of how we read mathematical papers. We can make this explicit using contexts. We will not however, use contexts in our discussion of type theory but we will provide a formal exposition in the appendix.

\newpage

\section{A formal simply typed lambda calculus}
Our judgements:
\begin{center}
    \begin{tabular}{c | c}
        $\Gamma\ \mathrm{ctx}$ &  $\Gamma$ is a well-formed context. \\
        $\Gamma \vdash A\ \mathrm{Type}$ & $A$ is a type in context $\Gamma$. \\
        $\Gamma \vdash x : A$ & $x$ is a term of type $A$ in context $\Gamma$. \\
%        $\Gamma \vdash x \equiv y : A$ & the terms $x$ and $y$ of type $A$ are definitionally equal in context $\Gamma$
    \end{tabular}
\end{center}

Type theory ``will be about'' deriving judgements from other judgements. Which can be concisely summarised in the form of an inference rule

$$\frac{A_1\quad A_2 \quad \cdots \quad A_n}{B}$$

which says that given the judgements $A_1,\dots,A_n$ we can derive the judgement $B$.

\subsection{Structural rules}
We now look at the rules that govern contexts and the structure of our type system.

We begin with a rule stating that the empty context (which as contexts are sets or lists is well-defined) is well-formed. Which is another way of stating that the context was grown in a specified way and is not just an arbitrary list or set of variables.

\begin{prooftree}
    \AxiomC{}
    \RightLabel{empty-ctx}
    \UnaryInfC{$\varnothing$ ctx}
    \singleLine
\end{prooftree}

We also want the concatenation of two well-formed contexts to be well-formed.

\begin{prooftree}
    \AxiomC{$\Gamma$ ctx}
    \AxiomC{$\Delta$ ctx}
    \BinaryInfC{$\Gamma,\Delta$ ctx}
\end{prooftree}

We omit rules about repeating or removing repeated elements and ordering lists (think of them as finite sets).

A variable is a statement of the form $x : A$ where $x$ is known as the term and $A$ its type.

\subsection{Function types}

We introduce a formation rule for the function type.

\begin{prooftree}
    \RightLabel{$(\to)$-form}
    \AxiomC{$\Gamma \vdash A\ \mathrm{Type}$}
    \AxiomC{$\Gamma \vdash B\ \mathrm{Type}$}
    \BinaryInfC{$\Gamma \vdash A \to B\ \mathrm{Type}$}
\end{prooftree}

We now need a rule for producing terms of this new type. We introduce the introduction rule for the function type.

\begin{prooftree}
    \RightLabel{$(\to)$-intro}
    \AxiomC{$\Gamma, x : A \vdash y : B$}
    \UnaryInfC{$\Gamma \vdash (\lambda x . y) : A \to B$}
\end{prooftree}

We will sometimes call this lambda abstraction. We next introduce a way to apply these functions to terms in their domains. We introduce our elimination rule for the function type.

\begin{prooftree}
    \RightLabel{$(\to)$-elim}
    \AxiomC{$\Gamma \vdash f : A \to B$}
    \AxiomC{$\Gamma \vdash a : A$}
    \BinaryInfC{$\Gamma \vdash f(a) : B$}
\end{prooftree}

This is essentially useless unless we have a way to compute (or reduce) this expression. This is where our computation rule comes in. The computation rule will tell us how our elimination rule and introduction rule interact.
\begin{prooftree}
    \RightLabel{$(\to)$-comp}
    \AxiomC{$(\lambda x . y) : A \to B$}
    \AxiomC{$\Gamma, a : A \vdash (\lambda x.y)a : B$}
    \AxiomC{$\Gamma, x : A, y : B, (\lambda x . y) : A \to B, a : A \vdash (\lambda x . y) (a) : B$}
    \UnaryInfC{$\Gamma \vdash y[x / a] : B$}
\end{prooftree}

%%%%%%%%%%%%%%%%%%%%
\newpage

We will describe a general class of simple type theories as outlined in \cite{JacobsCLTT}. Firstly we introduce the notion of a {\it signature}. 

\begin{defin}
	A {\bf many-typed signature} is a pair $(T, \mathcal{F})$ where $T$ is a countable set (most probably finite?) of {\bf basic} (or {\bf atomic}) {\bf types}. And a functor $\mathcal{F} : T^\star \times T \to \Set$. Where $T^\star$ is the Kleene-Star operation on a set (or the free monoid over $T$), defined as $T^\star := \bigcup_{n\in \N} T^n$ whose elements are finite tuples of elements of $T$. We have $\mathbf{Set}$ for the category of finite sets. Note that the sets in the domain of the functor are realised as discrete categories.
\end{defin}

We will usually write a signature as $\Sigma := (T, \mathcal{F})$, denote $|\Sigma|:=T$ and write $F: \sigma_1,\dots,\sigma_n\to\sigma_{n+1}$ when $F \in \mathcal{F}(\langle \sigma_1,\dots,\sigma_n \rangle, \sigma_{n+1})$.

\begin{example}
	Groups, monoids, natural numbers?
\end{example}

\begin{defin}
	A variable decleration is a pair $(x, \sigma)$
\end{defin}




