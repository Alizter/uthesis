\section{Simply typed lambda calculus with products, sums and natural numbers}

\subsection{Introduction}

Historically the addition of a natural numbers type with a recursion principle $\N$ was done by G\"odel in his \emph{``System T''} of Higher-Order recursion. This is different than having \emph{encoded} numbers in type theory. For example in \stlc we have \emph{Church numerals} [[CITE EXAMPLE]], and we have seen that it is possible to do basic arithmetic with. Church-Encodings are what are known as impredicative encodings, whereby the terms of the types are the same as the desired one but the eliminators are not present. This is demonstrated for Church-encodings of the natural numbers by the fact that it is \emph{impossible} to define recursion over the natural numbers in \stlc \cite{a} [[CITATION NEEDED]]. This isn't the case for \emph{untyped} lambda calculus however. It is well-known that untyped lambda calculus can have recursive definitions, but they come at a cost. Not every term in untyped lambda calculus is normalising. This corresponds to a computation which doesn't halt and is intimately related to the halting problem.[[CITE]] A natural numbers type can however be added to \stlc leading to a type theory that is ``equivalent'' to G\"odel's system T.

We will also look at some other types such as sums and $0$ and eventually exhibit the properties of this type theory as a propositional logic, as the Curry-Howard correspondence suggests.

\subsection{Natural numbers}

We add natural numbers. This will be our first example of an \emph{inductive type}. We will call the corresponding type theory $\lambda_{\to \times \N}$ and note that it enjoys \emph{canonicity}. Meaning that not only do all terms \emph{normalise} but they normalise to a canonical form. This means if we have a function that computes a natural number, we are guaranteed to get a numeral (an iterated number of successors to zero). If we had some rules in our type theory that broke canonicity, we may get a term that type checks as a natural number but isn't judgmentally equal to one.

\subsection{Sum types}

[[Sum types go by the name of unions in C, whereas product types correspond to structs.]]

They are like disjoint unions of sets.

Their induction principle is very simple, to build a function out of $A + B$ it suffices to give a function out of $A$ and another out of $B$.


