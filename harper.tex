% harper

\section{Type theory}

\subsection{Introduction}

We will follow the structure of syntax outlined in Harper \cite{harper_2016}. There are several reasons for this. Firstly, for example in Barendregt \cite{BarendregtHenk2013Lcwt} we have notions of substitution left to the reader under the assumption that they can be fixed. Generally Barendregt's style is like this and even when there is much formalism, it is done in a way that we find peculiar. We will follow Harper as an up to date, reputable and modern source.

In other type theory books such as \cite{CroleRoyL1993Cft, LambekJ1986Itho} not much attention is given to the syntax. For example notions like substitution are defined directly on terms of a lambda calculus, which we disagree with wholeheartedly. We think it is important to have a well-defined and well-understood notion of syntax before defining any type theories for a few reasons, firstly the structures we use are well understood and studied by other computer scientists in areas such as compilers [REF], and secondly, it will give us good notions of variables, bound variables and substituion. Also, our chosen structure will allow us to derive the semantics of our type theories in a much easier way, whereas if we hadn't paid attention to syntax we would have trouble keeping things well defined.


\subsection{Syntax}

We begin by outlining what exactly syntax is, and how to work with it. This will be important later on if we want to prove things about our syntax as we will essentially have good data structures to work with.

%We will begin with the notion of an {\it abstract syntax tree}. Which can be what is informally known as syntax, thus formal statements about the syntax are referring to its manifestation as an abstract syntax tree.

%% Sort
\begin{defin}[Sorts]
    Let $\mathcal{S}$ be a finite set, which we will call \textbf{sorts}. An element of $\mathcal{S}$ is called a \textbf {sort}.
\end{defin}

A sort could be a term, a type, a kind or even an expression. It should be thought of an abstract notion of the kind of syntactic element we have. Examples will follow making this clear. Let us fix a set $\mathcal S$.

%% Arity
\begin{defin}[Arities]
    An \textbf{arity} is an element $((s_1,\dots,s_n),s)$ of the set of \textbf{arities} $\mathcal{Q}:=\mathcal{S}^\star \times \mathcal{S}$ where $\mathcal{S}^\star$ is the Kleene-star operation on the set $\mathcal{S}$ (a.k.a the free monoid on $\mathcal{S}$ or set of finite tuples of elements of $\mathcal{S}$). An arity is typically written as $(s_1,\dots,s_n)s$. 
\end{defin}

Similarly to before, we fix a set $\mathcal{Q}$ of arities.

%% Operator
\begin{defin}[Operators]
    Let $\mathcal{O} :=\{ \mathcal{O}_\alpha \}_{\alpha \in \mathcal{Q}}$ be an $\mathcal{Q}$-indexed (arity-indexed) family of disjoint sets of \textbf{operators} for each arity. An element $o \in \mathcal{O}_\alpha$ is called an \textbf{operator} of arity $\alpha$. If $o$ is an operator of arity $(s_1,\dots,s_n)s$ then we say $o$ has \textbf{sort} $s$ and that $o$ has $n$ \textbf{arguments} of sorts $s_1,\dots,s_n$ respectively.
\end{defin}

Fix an $\mathcal{Q}$-indexed family $\mathcal{O}$ of sets of operators of each arity in $\mathcal{Q}$.

%% Variables
\begin{defin}[Variables]
    Let $\mathcal{X}:= \{ \mathcal{X}_s\}_{s \in \mathcal{S}}$ be an $\mathcal{S}$-indexed (sort-indexed) family of disjoint (finite?) sets $\mathcal{X}_s$ of \textbf{variables} of sort $s$. An element $x\in\mathcal{X}_s$ is called a \textbf{variable} $x$ of \textbf{sort} $s$. 
\end{defin}

%% Fresh variables
\begin{defin}[Fresh variables]
    We say that $x$ is \textbf{fresh} for $\mathcal{X}$ if $x \not\in \mathcal{X}_s$ for any sort $s\in \mathcal{S}$. Given an $x$ and a sort $s\in \mathcal{S}$ we can form the family $\mathcal{X},x$ of variables by adding $x$ to $\mathcal{X}_s$. 
\end{defin}

%% Remark about notation for adding variables
\begin{remark}
    The notation $\mathcal{X},x$ is ambiguous because the sort $s$ associated to $x$ is not written. But this can be remedied by being clear from the context what the sort of $x$ should be.
\end{remark}

\begin{defin}[Abstract syntax tree]
    The family $\mathcal{A}[\mathcal{X}]=\{ \mathcal{A}[\mathcal{X}]_s \}_{s \in \mathcal{S}}$ of \textbf{abstract syntax trees} (or asts), of \textbf{sort} $s$, is the smallest family satisfying the following properties:
    
    \begin{enumerate}
        \item A variable $x$ of sort $s$ is an ast of sort $s$: if $x \in X_s$, then $x \in \mathcal{A}[\mathcal{X}]_s$.
        
        \item Operators combine asts: If $o$ is an operator of arity $(s_1, \dots, s_n)s$, and if $a_1 \in \mathcal{A}[\mathcal{X}]_{s_1}, \dots, a_n \in \mathcal{A}[\mathcal{X}]_{s_n}$, then the ast $o(a_1;\dots; a_n) \in \mathcal{A}[\mathcal{X}]_s$.
    \end{enumerate}
\end{defin}

[Draw a picture here]

\begin{remark}
    The idea of a smallest family satisfying certain properties is that of structural induction. So another way to say this would be a family of sets inductively generated by the following constructors.
\end{remark}

\begin{remark}
    An ast can be thought of as a tree whose leaf nodes are variables and brach nodes are operators. 
\end{remark}

\begin{remark}
    When we prove properties $\mathcal{P}(a)$ of an ast $a$ we can do so by structural induction on the cases above.
\end{remark}

\begin{lemma}
    We have $\mathcal{A}[\mathcal{X}] \subseteq \mathcal{A}[\mathcal{Y}]$ if and only if $\mathcal{X} \subseteq \mathcal{Y}$.
\end{lemma}


