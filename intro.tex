\section{Introduction}

%Simply typed lambda calculus (STLC) has been well documented and studied by type theorists and mathematicians, and it's features have been used by many programming languages [NEED REFERENCE].

%In \cite{BarendregtHenk2013Lcwt} it is noted that \say{Research monographs on dependent and inductive types are lacking.} This will essentially be one of the goals of this thesis, to provide a guide for mathematicians and computer scientists about the use of dependent type theory. As this document is written there is no single account of all approaches to \i{dependent} type theory.

%Awodey \cite{2014arXiv1406.3219A} made an observation that Dybjer's \cite{dybjer1996} categories with families (CwF) is a presheaf category with a representable natural transformation (it's fibers are representable). He then proceeds to show conditions needed to model a dependent type theory with $\Pi$, $\Sigma$ and $\mathrm{Id}$ types.


%This thesis will have three main goals.

%\begin{enumitem}
%	\item To present a dependent type theory
%	\item To model the semantics of such a type theory using categorical methods
%	\item To discuss the applications to mathematics and computer science (proof assistants, programming languages and foundations)
%\end{enumitem}

%Finally we may also discuss recent developments of something called "Homotopy type theory" and how that fits into the general picture.

%Roughly a \textit{type system} is a set of loosely organised rules outlining how ``atomic sentences'' called \textit{judgements} can be derived from each other in a given context. A \textit{context} can simply be thought of as a list of terms. 

%The aim of this thesis is to present to two sorts of audience, the utility of dependent type theory. The audiences that I have in mind are computer scientists, roughly individuals who wish to write good code, and mathematicians, roughly individuals who wish to write good proofs.

%These will be our main aims however we do also wish to develop the machinery formally.

%\section{Propositions as types}

%There is a rich interplay between programming and logic known as the Curry-Howard correspondance or propositions as types. 





%\section{What is type theory}

%Type theory is the study of types systems. That is a system that orginizes data manipulated by programs into types. This has been a very useful concept in computer science. It has allowed the writing of programs taht a more 

%\subsection{Lambda calculus}
%\subsection{Modelling type theory}
%\section{What is dependent type theory?}
%\subsection{What are dependent types?}
%\subsection{Motivation for computer scientists}
%\subsection{Motivation for mathematicians}
%\subsection{Category theory}
%\subsection{Categorical logic}
%\subsection{Future directions}

\begin{itemize}
\item a[Begin with history and implications of curry howard]

\item a[outline the ``what they should do'' of dependent types]

\item a[start to rigoursly model syntax and talk about how bad a job most authors do]

\item a[small section about classical inductive definitions]

\item a[small section on why categorical semantics]

\item a[model simply typed lambda calculus with categorical semantics]

\item a[show natural extensions of the idea and why contexts break when dependnet]

\item a[outline different approches to solving these problems]

\item a[discuss Awodey's natural models]

\item a[finally talk about future directions for type theory]

\item a[maybe some mention on applications to programming (generalising various constructs, polymorphism, GA data types)]

\item a[equality, inductive types, [[[[[maybe a tinsy bit of homotopy type theory]]]]]]
\end{itemize}

\section{Curry-Howard correspondance}

\subsection{Mathematical logic}

At the beginning of the 20th century, Whitehead and Russell pubished their \emph{Principia Mathematica} \cite{GlossarWiki:Whitehead_Russell:1910}, demonstrating to mathematicians of the time that formal logic could express much of mathematics. It served to popularise modern mathematical logic leading to many mathematicians taking a more serious look at topic such as the foundations of mathematics.

One of the most influencial mathematicians of the time was David Hilbert. Inspired by Whitehead and Russell's vision, Hilbert and his coleagues at G\"ottingen became leading researchers in formal logic. Hilbert proposed the \emph{Entscheidungsproblem} (decision problem), that is, to develop an ``effectually calculable procedure'' to determine the truth or falsehood of any logical statement. At the 1930 Mathematical Congress in K\"onigsberg, Hilbert affirmed his belief in the conjecture, concluding with his famous words ``Wir m\"ussen wissen, wir werden wissen'' (``We must know, we will know''). At the very same conference, Kurt G\"odel announced his proof that arithmetic is incomplete \cite{GlossarWiki:Goedel:1931}, not every statement in arithmetic can be proven.

This however did not deter logicians, who were still interested in understanding why the \emph{Entscheidungsproblem} was undecidable, for this a formal efinition of ``effectively calculable'' was required. So along came three proposed definitions of what it meant to be ``effectively calculable'': \emph{lambda calculus}, pusblished in 1936 by Alonzo Church \cite{church-unsolvableproblemof-1936}; \emph{recursive functions}, proposed by G\"odel in 1934 later published in 1936 by Stephen Kleene \cite{Kleene1936}; and finally \emph{Turing machines} in 1937 by Alan Turing \cite{turing1936a}.

\subsection{Lambda calculus}

(Untyped) lambda calculus was discovered by Church at princeton, originally as a way to define notations for logical formulas. It is a remarkaly compact idea, with only three constructs: variables; lambda abstraction; and function application. It was realised at the time by Church and others that ``There may, indeed, be other applications of the system than its use as a logic.'' [CITATION NEEDED]\cite{}. Church discovered a way of encoding numbers as terms of lambda calculus. From this addition and multiplication could be defined. Kleene later discovered how to define the predecessor function. [CITATION NEEDED] \cite{}. Church later rpoposed $\lambda$-definability as the definition of ``effectively calculable'', what is now known as Church's Thesis, and demonstrated that the problem of determining whether or not a given $\lambda$-term  has a normal form is not $\lambda$-definable. This is now known as the Halting Problem. 

\subsection{Recursive functions}

In 1933 G\"odel arrived in Princeton, unconvinced by Church's claim that every effectively calculable function was $\lambda$-definable. Church responded by offering that if Go\"odel would propose a different definition, then Church would ``undertake to prove it was included in $\lambda$-definability''. In a series of lectures at Princeton, G\"odel proposed what came to be known as ``general recursive functions'' as his candidate for effective calculability. Kleene later published the definition [CITATION NEEDED]\cite{}. Church later outlined a proof [CITATION NEEDED]\cite{} and Kleene later published it in detail. This however did not have the intended effect on G\"odel, whereby he then became convinced that his own definition was incorrect.

\subsection{Turing machines}

Alan Turing was at Camrbdige when he independently formulated his own idea of what it means to be "effectively calculable", now known today as Turing machines. He used it to show that the Entscheidungsproblem is undecidable, that is it cannot be proven to be true or false. Before publication, Turing's advisor Max Newman was worried since Church had published a solution, but since Turing's approach was sufficiently novel it was published anyway. Turing had added an appendix sketching the equivalence of $\lambda$-definability to Turing machines. It was Turings argument that later convinced G\"odel that this was the correct notion of ``effectively calculable''.

\subsection{Russells paradox}

[Talk about the origin of types and stuff]

\subsection{The problem with lambda calculus as a logic}

Church's lambda calculus turned out to be inconsistent. \cite{}[CITATION NEEDED]. The reason was related to russels paradox, in that a predicate was allowed to act on itself. This led to an abandoning of the use of lambda calculus as a logic for a short time. In order to solve this Church adapted a solution similar to Russell's: use types. What was discovered is now known today as \emph{simply-typed lambda calculus}. \cite{} [CITATION NEEDED, 10 ?]. What is nice about Church's STLC is that every term has a normal form, or in the language of Turing machines every computation halts. \cite{} [CITATION NEEDED] From this consistency of Church's STLC as a logic could be established.

\subsection{Types to the rescue}

[Talk in detail why typing is good for mathematicians, programmers and logicians]

\subsection{The theory of proof a la Gentzen}

[Go into the history of the theory of proof e.g. Gentzen's work; take notice of natural deduction]

\subsection{Curry and Howard}

[Curry makes an observation that Gentzens natural deduction corresponds to simply typed lambda calculus, Howard takes this further and defines it formally, eventually predicting a notion of dependent type.

\subsection{Propositions as types}

[Overview of the full nature of the observation, much deeper than a simple correspondance since logic is in some sense ``very correct'' and programming constructs corresponding to these must therefore also be ``very correct''.]

\subsection{Predicates [CHANGE] as types?}

[Talk about predicate quantifiers $\forall, \exists$ and what a ``dependent type ought to do'']


\subsection{Dependent types}




[Perhaps expand on the simply typed section]

[talk about pi and sigma types

[talk about ``dependent contexts'']


